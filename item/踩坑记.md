# 云对讲

* 启动本地`redis`

  ```shell
  cd /Applications/workspace/redisInstall/redis-5.0.2
  ./src/redis-server redis.conf 
  ./src/redis-cli -a qwer6379
  ```

* 更新功能之前，考虑下是否需要先造点旧数据，比如人脸识别升级

* `BufferedImage image = ImageIO.read(inputStream);`返回为null

  * 因为该`inputStream`不是文件（图片）转换成的`inputStream`，不是图片流而是数据流，所以不能转成图片

* 将`MultipartFile`转为`File`

  ```java
  private File getFileByMultipartFile(MultipartFile multipartFile) {
    if(multipartFile != null) {
      CommonsMultipartFile cf= (CommonsMultipartFile)multipartFile;
      DiskFileItem fi = (DiskFileItem)cf.getFileItem();
      if(fi != null) {
        return fi.getStoreLocation();
      }
    }
    return null;
  }
  ```

* 将`URL`转成`File`

  ```java
  URL urlInfo = new URL(imgUrl);
  File file = new File(urlInfo.toURI().getPath());
  ----
  FileUtils.copyURLToFile(imgUrl, new File("/Users/dingyuanjie/Downloads/test.png"));
  
  //待测试
  BufferedImage image = ImageIO.read(new File(imgUrl));
              ByteArrayOutputStream bs = new ByteArrayOutputStream();
              ImageOutputStream imOut = ImageIO.createImageOutputStream(bs);
              ImageIO.write(image, "png", imOut);
              InputStream inputStream = new ByteArrayInputStream(bs.toByteArray());
  ```

* 本地代码远程Debug Linux上的Tomcat

  * `tomcat`的`bin`目录下`catalina.sh`文件中

    ```java
    //CATALINA_OPS属性中增加-Xdebug -Xrunjdwp:transport=dt_socket,address=6004,server=y,suspend=n"
    //设置JPDA_ADDRESS="6004"
    
    CATALINA_OPS="$CATALINA_OPTS -Dfile.encoding=UTF8 -Djava.net.preferIPv4Stack=true  -Dorg.apache.catalina.loader.WebappClassLoader.ENABLE_CLEAR_R
    EFERENCES=false -Duser.timezone=GMT+8  -Xms256m -Xmx1024m -XX:PermSize=128m -XX:MaxPermSize=256m  -Xdebug -Xrunjdwp:transport=dt_socket,address=
    6004,server=y,suspend=n"
    ```

  * 外部能`telnet`通6004端口：`telnet ip 6004`
  * 服务器启动方式
    * `cd bin/`
    * `./catalina.sh jpda start`

* maven项目添加外部依赖

  ```xml
  <dependency>
    <groupId>com.arcsoft</groupId>
    <artifactId>face</artifactId>
    <version>2.1</version>
    <scope>system</scope>
    <systemPath>${project.basedir}/../efastFR/libs/arcsoft-sdk-face-2.1.0.0.jar</systemPath>
  </dependency>
  ```

* maven打包失败，提示`/efastFR/lib不存在`
  
  * 在`efastFR`下新建`lib`目录
  
* `tomcat7`换成`tomcat8`时，`conf/context.xml`中`jdbc`的配置属性名称需要更改

* java.io.IOException: Broken pipe

  ```java
  URL faceUrl = new URL(imgUrl);
  URLConnection urlConnection = faceUrl.openConnection();
  urlConnection.setConnectTimeout(5000);
  urlConnection.setReadTimeout(5000);
  urlConnection.getInputStream();
  //Inputstream转为byte[]  import org.apache.commons.io.IOUtils;
  IOUtils.toByteArray(con.getInputStream());
  
  new File(Objects.requireNonNull(LocalFileUtils.getFullPath(imgFullPath)))
  ```
  
* ==人脸识别工具类中方法调用==

  * 问题：工具类中引擎对象为null，导致出现空指针异常
  * 原因：引擎对象没初始化，使用之前必须先初始化，是根据web容器启动(监听)而初始化，所以需要将初始化类配置到web.xml的监听器中
  * 只有app和web模块配置了引擎初始化，所以只能在这两个模块中使用人脸识别工具，在其他模块，如service模块中就不能使用，因为引擎没初始化
  
* 写业务功能之前，先把逻辑理顺，先干什么，再干什么，最后干什么

* 查看tomcat日志

  * `tail -2000 all.log`

* 日志`slf4j`

  * 本地调试报错时，如果要看到SQL语句及参数，将Log（Log4j）日志级别改为==Debug模式==
  * `private static final Logger logger = LoggerFactory.getLogger(Abc.class);`
  * 使用占位符`logger.debug("Processing trade with id: {} and symbol : {} ", id, symbol);`
  * 避免重复打印日志，浪费磁盘空间，务必在 log4j.xml中设置 additivity=false，`<logger name="com.taobao.dubbo.config" additivity="false">`

* 异常处理

  * 异常信息应该包括两类信息：案发现场信息和异常堆栈信息。如果不处理，那么通过关键字==throws== 往上抛出`logger.error(各类参数或者对象toString() + "_" +e.getMessage(), e);`

* maven中有GAV配置，但是依赖没下载下来，报错了

  * 到本地maven仓库删除未下载完的依赖文件，然后会自动下载
  
* 将两个byte[]合并到一个新的byte[]

  ```java
  byte[] b = new byte[]{0x00, 0x00, 0x56, 0x04};
  byte[] face = (byte[]) redislistObj.get(houseHolderBean.getFaceId());
  
  byte[] result = new byte[b.length + face.length];
  //把b增加到face之前
  System.arraycopy(b, 0, faceByte, 0, b.length);
  System.arraycopy(face, 0, faceByte, b.length, face.length);
  ```

* 下载文件（可以测试验证下）
  * 获取文件的输入流
  * `IOUtils.copyLarge(文件流, HttpServletResponse.getOutputStream());`
  * `HttpServletResponse.getOutputStream().flush()`
  
* 返回Bean中的属性是个图片文件
  * 如果是本地的，则相对路径作为参数，传入到一个接口中，然后将接口地址及参数作为该Bean的属性返回
  * 如果是其他系统的，如OSS，则返回Http链接
  
* 文件存服务器本地
  * 完整的地址分为两段，更具有灵活性
    * 第一段，在配置文件中配置，从服务器的根目录开始的几层目录
    * 第二段，文件的相对路径，也是存入标中的路径
  
* StringUtils工具类

  ```java
  <dependency>
  	<groupId>org.apache.commons</groupId>
  	<artifactId>commons-lang3</artifactId>
  	<version>3.0</version>
  </dependency>
  
  StringUtils.defaultIfBlank(this.node, "")
  ```

* ==访问报错，第一时间去看服务器上日志==

* ==善于用工具类==

* 尽量避免重复代码，善于封装方法

* boolean在MySQL里的类型为tinyint(1)

  * POJO类中定义成boolean，在mysql中定义成tinyint(1)
  
* 有Oracle时POJO不要用true和false，用0和1

  * 要不然巨坑

* 多表更新

  ```sql
  UPDATE  t1
  LEFT JOIN t2 ON t2.id = t1.id
  SET     t1.col1 = newvalue
  WHERE   t2.id IS NULL
  ```

* 从lov中查找数据（从数据库中），即新增数据时不用重新部署

* ```java
  private static DecimalFormat fnum = new DecimalFormat("##0.00");
  fnum.format(score*100)
  ```

* 分页

  ```java
  @GetMapping("/experiencesissue")
  @ResponseBody
  public Page<QualityIssue> queryExperience(PageQueryBean bean) {
    return service.queryExperience(bean);
  }
  
  public class PageQueryBean extends Page implements Serializable{
    private String startTime;
    private String endTime;
    ...
  }
  
  public class Page<T> implements Serializable{
    private int page;
    @JsonIgnore
    private int startIndex;
    private int size = 10;
    private int totalPages;
    private long count;
    private List<T> data;
    public Page<T> init(List<T> data, long count) {
          this.data = data;
          this.count = count;
          this.totalPages = (int) ((count + size - 1) / size);
          this.page = Math.max(1, page);
          return this;
    }
    @JsonIgnore
    public int getStartIndex() {
      return Math.max(page - 1, 0) * size;
    }
    ...
  }
  
  public Page<QualityIssue> queryExperience(PageQueryBean bean) {
    Page<QualityIssue> result = new Page<>();
    bean.setFormType("experience");
    List<QualityIssue> list = dao.queryExperienceList(bean);
    int count = dao.queryExperienceCount(bean);
    return result.init(list, count);
  }
  ```

  ```sql
  SELECT
  	<include refid="issueDetail"/>
  from t_quality_issue
  where form_type = #{formType}
  <if test="startTime != null and startTime !=''">
  	and create_time &gt;= #{startTime}
  </if>
  <if test="endTime != null and endTime !=''">
  	and create_time &lt;= #{endTime}
  </if>
  order by last_update_time desc
  limit #{startIndex}, #{size}
  
  SELECT
  	count(*)
  from t_quality_issue
  where form_type = #{formType}
  <if test="startTime != null and startTime !=''">
  	and create_time &gt;= #{startTime}
  </if>
  <if test="endTime != null and endTime !=''">
  	and create_time &lt;= #{endTime}
  </if>
  ```

* 上传到服务器本地，从服务器本地下载

  ```java
  // 上传时覆盖相同文件名
  public static void main(String[] args) throws IOException {
    File file = new File("/Users/dingyuanjie/Documents/study/github/22/redis.pdf");
    File dir = new File("/Users/dingyuanjie/Documents/study/github/11/");
    InputStream inputStream = new FileInputStream(file);
    FileUtils.copyInputStreamToFile(
      inputStream,
      new File(dir.getCanonicalPath(), file.getName()));
  }
  ```

* `! [remote rejected] master -> master (pre-receive hook declined)`

  * 权限问题
  
* `BeanUtils`

  ```java
  //相同属性将被复制
  BeanUtils.copyProperties(Object source, Object target);
  ```

* catch多个异常块，只会在一个异常块中处理

* 建表时要加上`create_time`、`last_update_time`、`is_delete`、`create_user`、`last_update_user`

* windows复制

  ```java
  C:\Users\tking\Desktop\war\1> copy D:\env\beijing\**\target\*.war C:\Users\tking\Desktop\war\1
  ```

* oracle表主键自动增长

  ```shell
  --给表设置自增主键
  修改id为自增:id int generated by default on null as identity (start with 10000) primary key

  # 无效字符
  仔细看打印的日志，应该有乱码字符
  表的别名最后一个字符不要和left等连接关键字的第一个字符相同
  ```

* `20170926010203   yyyy-MM-dd HH:mm:ss`

  ```java
  StringBuilder sb = new StringBuilder(str);
  sb.insert(4, "-");
  sb.insert(7, "-");
  sb.insert(10, " ");
  sb.insert(13, ":");
  sb.insert(16, ":");
  ```

* 项目redis启动报错：无法从redis连接池中获取连接，==要看完整的报错信息，不能只看第一条==
  * 项目redis设置密码，所以redis服务器的redis.conf的配置文件中设置相应密码`requirepass qwer6379`
  * 然后指定配置文件redis.conf启动redis服务端
  
* RequestMapping的method缺省

  * 可以处理任何方式的 http method 类型的请求

* 页面查询返回没数据，而把SQL复制出来到数据库查询有数据

  * 连接不同的数据库导致

* 图片与Base64字符串互转

  ```java
  ByteArrayOutputStream os = new ByteArrayOutputStream();
  File file = new File("/Users/dingyuanjie/Documents/work/QAK/png/1.png");
  BufferedImage read = ImageIO.read(file);
  ImageIO.write(read, "png", os);
  // 还原的话，前面加上 data:image/png;base64,
  String s = Base64.getEncoder().encodeToString(os.toByteArray());
  System.out.println(s);
  
  OutputStream out = new FileOutputStream(new File("/Users/dingyuanjie/Documents/work/QAK/png/111.png"));
  byte[] decodeByte = Base64.getDecoder().decode(s);
  ByteArrayInputStream bis = new ByteArrayInputStream(decodeByte);
  BufferedImage img = ImageIO.read(bis);
  //将图片写入指定文件
  ImageIO.write(img, "png", out);
  ```

* Oracle Long型日期与格式化日期互转

  ```sql
  -- Long型日期转格式化日期
  SELECT TO_CHAR(1524013682750 / (1000 * 60 * 60 * 24) +
                 TO_DATE('1970-01-01 08:00:00', 'YYYY-MM-DD HH:MI:SS'), 'YYYY-MM-DD HH:MI:SS') AS CDATE
  FROM DUAL;
  
  -- 格式化日期转Long型日期
  SELECT TO_NUMBER(TO_DATE('2018-04-18 09:08:03', 'YYYY-MM-DD HH24:MI:SS') -
                   TO_DATE('1970-01-01 08:00:00', 'YYYY-MM-DD HH24:MI:SS')) * 24 * 60 * 60 * 1000 as str
  FROM DUAL;
  ```

* `@DateTimeFormat`和`@JsonFormat`

  ```java
  // 将请求参数为yyyy-MM-dd HH:mm:ss类型字符串自动转换为Date类型数据
  @DateTimeFormat(pattern = "yyyy-MM-dd HH:mm:ss")
  private Date startTime;
  
  // 返回给客户端时，Date类型的数据自动转换为14位的字符串返回出去
  @JsonFormat(pattern="yyyy-MM-dd HH:mm:ss",timezone="GMT+8")
  private Date updateTime;
  ```

* for循环中，遇到continue则跳出当次循环，即不继续执行continue下面的代码，开始下次循环

  * 在try中throw new ServiceException()，在catch中处理，不会中断for循环

* controller层报错，提示request、response需要序列化

  * 原因是通过hessian代理来调用service时需要序列化
  * 将涉及request、response的调用移动到controller层
  * 例如文件下载，在controller层处理

* ```java
  org.springframework.remoting.RemoteAccessException: Cannot access Hessian remote service at [http://10.0.0.62:8090/community.manage-service/remote/manage/houseHolderManageService]; nested exception is com.caucho.hessian.io.HessianProtocolException: '￿' is an unknown code
  // Hessian中不要传流                                                                                             
  ```

* 浏览器文件下载

  * 前端最好用`window.open`去调用后端接口下载，不要用ajax
  * 用form提交、`window.location.href`
  * 问题：用ajax下载txt、log等文本文件时会在浏览器里打开而不下载

  ```java
  String fileName = equipmentArea.getG_addr() + "_" + DateUtils.format(new Date(), DateUtils.FORMAT_DATE_YYYY_MM_DD) + ".log";
  String path = ConfigUtil.getUploadDir()+ "/" + FilePathEnum.entrance_machine.getPath() + "/" + fileName;
  //            LocalFileUtils.download(path, response);
  // path是指欲下载的文件的路径。
  File file = new File(path);
  // 取得文件名
  String filename = file.getName();
  // 取得文件的后缀名。
  String ext = filename.substring(filename.lastIndexOf(".") + 1).toUpperCase();
  
  // 以流的形式下载文件。
  InputStream fis = new BufferedInputStream(new FileInputStream(path));
  byte[] buffer = new byte[fis.available()];
  fis.read(buffer);
  fis.close();
  // 清空response
  //            response.reset();
  // 设置response的Header
  response.addHeader("Content-Disposition", "attachment;filename=" + new String(filename.getBytes()));
  response.addHeader("Content-Length", "" + file.length());
  OutputStream toClient = new BufferedOutputStream(response.getOutputStream());
  response.setContentType("application/octetc-download");
  toClient.write(buffer);
  toClient.flush();
  toClient.close();
  ```

* 通过浏览器console查看调用接口
  
* 云对讲框架细节
  
  * 登录、拦截器
  * socketIO
  * hessian
  
* oracle批量插入

  ```xml
  <insert id="saveAttachmentForm" useGeneratedKeys="false" keyColumn="id">
          insert into portal_attachment_form
          (formId,attachmentId,orderNumber,indexName,groupId,company_code,opt_counter,create_time,last_update_time,create_user,last_update_user)
  
          <foreach collection="attachmentForms" item="obj" index="index"
                   separator=" union all ">
              select #{obj.formId} as formId,
                     #{obj.attachmentId} as attachmentId,
                     #{obj.orderNumber} as orderNumber,
                     #{obj.indexName} as indexName,
                     #{obj.groupId} as groupId,
                     #{companyCode} as companyCode,
                     1,
                     sysdate as sysdate1,
                     sysdate as sysdate2,
                     #{requestUser} as requestUser1,
                     #{requestUser} as requestUser2
              from dual
          </foreach>
      </insert>
  ```

* 即使前端传字符串，后端startTime和endTime定成Date类型，可以在接收之前将字符串类型转为Date类型，然后时间之间可以直接比较大小

* Linux目录文件查找

  * `ls -lh *.log`

* 日期

  ```java
  TO_CHAR(tu.u_createdate,'YYYY-MM-DD HH24:MI:SS') as submitTime
  and	homs.create_time &gt;= to_date(#{startTime}, 'yyyy-mm-dd hh24:mi:ss')
  ```

* 对系统外传入的数据，如时间，要进行格式校验

* 浏览器下载文件

  ```java
  //普通文件下载
  File file = new File(ConfigUtil.getUploadDir()+FilePathEnum.entrance_machine.getPath()+"/" + bean.getUploadName());
  byte[] videoBytes = FileUtils.readFileToByteArray(file);
  
  response.addHeader("Content-Disposition", "attachment;filename=" + new String(bean.getUploadName().getBytes()));
  response.addHeader("Content-Length", "" + videoBytes.length);
  OutputStream toClient = new BufferedOutputStream(response.getOutputStream());
  // video/mpeg4
  response.setContentType("application/octetc-download");
  toClient.write(videoBytes);
  toClient.flush();
  toClient.close();
  ```

  ```java
  //压缩下载
  ByteArrayOutputStream baos = new ByteArrayOutputStream();
  ZipOutputStream zos = new ZipOutputStream(baos);
  String[] files = {"/Users/dingyuanjie/Downloads/8O1Ry_2019-06-13_11-40-57_200902041905170024.mp4","/Users/dingyuanjie/Downloads/EGuXK_2019-06-13_11-36-58_200902041905170024.mp4"};
  for (String fileName : files) {
    // 名字可以自定义，但是要带上后缀名
    zos.putNextEntry(new ZipEntry(fileName.substring(29,35) + ".mp4"));
    zos.write(FileUtils.readFileToByteArray(new File(fileName)));
    zos.closeEntry();
  }
  zos.flush();
  baos.flush();
  zos.close();
  baos.close();
  
  ServletOutputStream sos = response.getOutputStream();
  response.setContentType("application/zip");
  response.setHeader("Content-Disposition", "attachment; filename=" + "111.zip");
  
  sos.write(baos.toByteArray());
  sos.flush();
  ```

* oracle中，标中FILE字段与系统保留字FILE冲突
  
  * 使用时，双引号包裹FILE，如"FILE"
  
* 异步执行

  ```java
  @Configuration
  @EnableAsync
  public class SpringAsyncConfig {
      @Bean(name = "asyncTaskExecutor")
      public TaskExecutor specificTaskExecutor() {
          ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
          executor.setThreadNamePrefix("asyncTasks-");
          Integer asyncTaskThreadSize = ConfigUtil.getIntValue("asyncTaskThreadSize", 20);
          if (asyncTaskThreadSize != null) {
              executor.setCorePoolSize(asyncTaskThreadSize);
              executor.setMaxPoolSize(asyncTaskThreadSize);
          }
          executor.initialize();
          return executor;
      }
  }
  ```

  ```java
  // 调用方法和实现方法不能在同一个类中
  @Service
  public class AsyncTestServiceImpl implements AsyncTestService {
    	@Async("asyncTaskExecutor")
      @Transactional(propagation = Propagation.REQUIRES_NEW, rollbackFor = Exception.class)
      @Override
      public void processData(JSONObject jsonData){
        logger.info("当前线程为................{}", Thread.currentThread().getName());
        ...
      }
  }
  
  public interface AsyncTestService{
    void processData(JSONObject jsonData);
  }
  ```

* maven 依赖红色波浪线报错，打包报错，提示某版本的包不存在
  
  * 添加相应的版本包
  
* 当涉及到两个操作时，要考虑到异步的情形该如何处理

  * 如门口机上传开门记录和上传开门照片，因图片名称有所改变，所以需考虑异步的后果
  * 考虑是否需要保留原图片名称，也可以再建一张表用于上传开门照片时存储图片的原名称和新名称

* 生产环境排查问题

  * 如果日志没有打印错误信息，页面一直卡在那，可通过在调用的方法代码里多打几个日志标记，看看是执行到哪一步卡了
  
* 服务器访问突然出现很多接口报404，可能是war或class文件不存在，部署存在问题

  * 服务器日志文件中查找：`? qak_vaw_service`

* SpringBoot启动报错`Caused by: java.lang.ClassNotFoundException: javax.servlet.ServletContext`

  * 解决`spring-boot-starter-tomcat`依赖注释掉`<!--<scope>provided</scope>-->`
  
* 设备是否在线条件查询（分页），应用挂掉后设备是否在线状态没能更新，导致实际不在线确显示在线

  * 查询时，controller里设置static boolean类型flag=true，调用查询接口时
    * 判断flag为true，则将所有设备设置不在线，然后查询redis中在线设备，然后更新相关设备是否在线，最后设置flag=false，不至于每次查询都调用该方法
    * 分页查询时，直接从数据库中查询

  ```java
  //controller.java
  private static boolean flag = true;
  if(flag) {
    logger.info(".........." + flag + "..................");
    // 根据redis更新设备是否在线
    communityGatewaysService.updateGatewayOnlineStatus();
    flag = false;
  }
  ...
  //service.java
  //dao.java
  void updateGatewayOnlineStatus(@Param("online") int online, @Param("list") List<Map<String,String>> list);
  //dao.xml
  <update id="updateGatewayOnlineStatus">
  	update t_gateways gateway
  	inner join t_community_gateway_extension extension on gateway.id = extension.gateway_id
  	left join t_community_equipment_area equipment_area on equipment_area.gateway_id = gateway.id
  	set gateway.g_online = #{online}
  	<if test="list != null and list.size() > 0">
  		where
  		<foreach collection="list" item="item" index="index" separator="or">
  			(gateway.g_addr = #{item.username} and equipment_area.company_code = #{item.companyCode})
  		</foreach>
  		and extension.status in ('activation','waitdetection' )
  	</if>
  </update>
  ```

* 仔细排查问题，一步一步向上排查，attachment，company_code为null

* 序列化/反序列化

  ```java
  // 序列化
  byte[] serialize(Object obj);
  // 反序列化
  <T> T deserialize(Class<T> clazz, byte[] bytes);
  ```

* 递增叠加尝试次数

  ```java
  public static void test(int maxTry) {
    int order = 5 - maxTry + 1;
    int delay = 1 << order;
    System.out.println("delay:" + delay); // 2、4、8、16、32
    if(order == 5) {
      return ;
    }
    test(5 - order);
  }
  ```

# Byton

* 初始化项目，gradle报插件异常
  * 解决：不要用brew，要下载安装包、解压、配置环境变量、引入到idea中
  * command + ,   设置gradle环境为 …/bin
  * 根源在于gradle环境没有安装对，要按照官网步骤来进行安装
* 运行时sl4j的log：查找不到log符号，但是java文件中没有报错
  
  * command + ,  然后 Annotation Processors 勾选 enable annotation processing

* String.format("%03d", str)

  * 如果str为1，则结果为001，如果str为2000，则结果为2000

* 新增和编辑时都要考虑是否会导致重复

* 不通类型的各自序列号递增

  * 表：类型，当前值、步长

  * 先根据类型查询数据库

    * 如果为null，则设置类型、当前值、步长，然后返回当前值
    * 否则，直接返回当前值

  * 然后，按照步长递增当前值

    ```java
    // 防止sql注入
    String sql = MessageFormat.format("update {0} set {1}={1}+{2} where {3} = ?",
                    Sequence._table,
                    Sequence._curVal,
                    Sequence._increment,
                    Sequence._id);
    jdbcTemplate.update(sql, seq.getId());
    ```

  * 考虑事务

    ```java
    @Transactional(isolation = Isolation.SERIALIZABLE)
    //方法
    ```

  * 序列号修改时，考虑继续递增，还是保持不变，只修改其他部分内容

```java
List<Student> stuList = new ArrayList<Student>();
        Student st1 = new Student("123","aaa");
        Student st2 = new Student("234","bbb");
        Student st3 = new Student("345","ccc");
        Student st4 = new Student("345","ccc");
        stuList.add(st1);
        stuList.add(st2);
        stuList.add(st3);
        stuList.add(st4);
        //1.提取出list对象中的一个属性
        List<Object> stIdList1 = stuList.stream()
                .map(Student::getName)
                .collect(Collectors.toList());
        stIdList1.forEach(s -> System.out.print(s+" "));
        System.out.println();
        System.out.println("----------");



// 字符串，否则精度有问题
        BigDecimal b = new BigDecimal("0.00450");
        BigDecimal multiply = b.multiply(FinanceProductUtil.getBigDecimalByInt(10000));

        System.out.println(String.format("%04d",multiply.intValue()));
```

```java
// 产品，基本信息—+多个feature，一个feature代表一个产品，重复性校验一条插入一条
// 更新状态：有问题（查出所有产品，然后遍历判断状态并更新状态），解决：直接根据条件更新，不用查所有再判断
// 未发布 变为 不可发布
        String sqlUnPublishToCanNotPublish = "update byton_vendor_finance_product set product_status = :statusAfter " +
                "where product_status = :statusBefore and period_of_validity_startdate <= date_format(now(), '%Y-%m-%d') and period_of_validity_enddate >= date_format(now(), '%Y-%m-%d')";
        Map<String, Integer> paramUpublishToCanNotPublishParam = new HashMap<>();
        paramUpublishToCanNotPublishParam.put("statusAfter", FinanceProductStatusEnum.UNPUBLISHED.getValue());
        paramUpublishToCanNotPublishParam.put("statusBefore", FinanceProductStatusEnum.CAN_NOT_PUBLISH.getValue());
        jdbcTemplate.update(sqlUnPublishToCanNotPublish, paramUpublishToCanNotPublishParam);
```

```java
// mysql
order by FIELD(`product_status` , 0, 1, 2, 3, 4), product.creation_date desc  

// 如果编辑比较复杂，则直接删除然后新增
// 可以建立配置表用来维护字段信息
// 编辑时考虑未修改数据直接提交，校验要通过
// 列表排序规则
// mysql bit 对应 java true和false
// mysql like ?  , 参数  "%" + param + "%"
// 有上级时，要注意是否要在上级的范围内查询
	// 如 名片需要在某子机构中查询
// get请求不要用json形式参数，用params
// 被终止后还能否再次创建（重复性校验增加未终止）
```

```sql
-- mysql实现distinct限制几列而查多列的方法  使用group by
SELECT *
FROM byton_vendor_partner_subsidiary
WHERE (parent_id = '5d382902e4b06fa517c9682a')
GROUP BY city_code, province_code
```

```xml
云对讲 
<dependency>
  <groupId>org.springframework.session</groupId>
  <artifactId>spring-session-data-redis</artifactId>
  <version>RELEASE</version>
  <!--<version>2.1.7.RELEASE</version>-->
</dependency>

<repository>
  <id>aliyun-central</id>
  <name>aliyun</name>
  <url>https://maven.aliyun.com/repository/central</url>
</repository>

<repository>
  <id>efast</id>
  <name>efast</name>
  <url>http://139.224.22.150:8081/nexus/content/groups/public/</url>
  <snapshots>
    <enabled>true</enabled>
  </snapshots>
</repository>
```

