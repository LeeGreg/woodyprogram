# 云对讲

* 启动本地`redis`

  ```shell
  cd /Applications/workspace/redisInstall/redis-5.0.2
  ./src/redis-server redis.conf 
  ./src/redis-cli -a qwer6379
  ```

* 更新功能之前，考虑下是否需要先造点旧数据，比如人脸识别升级

* `BufferedImage image = ImageIO.read(inputStream);`返回为null

  * 因为该`inputStream`不是文件（图片）转换成的`inputStream`，不是图片流而是数据流，所以不能转成图片

* 将`MultipartFile`转为`File`

  ```java
  private File getFileByMultipartFile(MultipartFile multipartFile) {
    if(multipartFile != null) {
      CommonsMultipartFile cf= (CommonsMultipartFile)multipartFile;
      DiskFileItem fi = (DiskFileItem)cf.getFileItem();
      if(fi != null) {
        return fi.getStoreLocation();
      }
    }
    return null;
  }
  ```

* 将`URL`转成`File`

  ```java
  URL urlInfo = new URL(imgUrl);
  File file = new File(urlInfo.toURI().getPath());
  ----
  FileUtils.copyURLToFile(imgUrl, new File("/Users/dingyuanjie/Downloads/test.png"));
  
  //待测试
  BufferedImage image = ImageIO.read(new File(imgUrl));
              ByteArrayOutputStream bs = new ByteArrayOutputStream();
              ImageOutputStream imOut = ImageIO.createImageOutputStream(bs);
              ImageIO.write(image, "png", imOut);
              InputStream inputStream = new ByteArrayInputStream(bs.toByteArray());
  ```

* 本地代码远程Debug Linux上的Tomcat

  * `tomcat`的`bin`目录下`catalina.sh`文件中

    ```java
    //CATALINA_OPS属性中增加-Xdebug -Xrunjdwp:transport=dt_socket,address=6004,server=y,suspend=n"
    //设置JPDA_ADDRESS="6004"
    
    CATALINA_OPS="$CATALINA_OPTS -Dfile.encoding=UTF8 -Djava.net.preferIPv4Stack=true  -Dorg.apache.catalina.loader.WebappClassLoader.ENABLE_CLEAR_R
    EFERENCES=false -Duser.timezone=GMT+8  -Xms256m -Xmx1024m -XX:PermSize=128m -XX:MaxPermSize=256m  -Xdebug -Xrunjdwp:transport=dt_socket,address=
    6004,server=y,suspend=n"
    ```

  * 外部能`telnet`通6004端口：`telnet ip 6004`
  * 服务器启动方式
    * `cd bin/`
    * `./catalina.sh jpda start`

* maven项目添加外部依赖

  ```xml
  <dependency>
    <groupId>com.arcsoft</groupId>
    <artifactId>face</artifactId>
    <version>2.1</version>
    <scope>system</scope>
    <systemPath>${project.basedir}/../efastFR/libs/arcsoft-sdk-face-2.1.0.0.jar</systemPath>
  </dependency>
  ```

* maven打包失败，提示`/efastFR/lib不存在`
  
  * 在`efastFR`下新建`lib`目录
  
* `tomcat7`换成`tomcat8`时，`conf/context.xml`中`jdbc`的配置属性名称需要更改

* java.io.IOException: Broken pipe

  ```java
  URL faceUrl = new URL(imgUrl);
  URLConnection urlConnection = faceUrl.openConnection();
  urlConnection.setConnectTimeout(5000);
  urlConnection.setReadTimeout(5000);
  urlConnection.getInputStream();
  //Inputstream转为byte[]  import org.apache.commons.io.IOUtils;
  IOUtils.toByteArray(con.getInputStream());
  
  new File(Objects.requireNonNull(LocalFileUtils.getFullPath(imgFullPath)))
  ```
  
* ==人脸识别工具类中方法调用==

  * 问题：工具类中引擎对象为null，导致出现空指针异常
  * 原因：引擎对象没初始化，使用之前必须先初始化，是根据web容器启动(监听)而初始化，所以需要将初始化类配置到web.xml的监听器中
  * 只有app和web模块配置了引擎初始化，所以只能在这两个模块中使用人脸识别工具，在其他模块，如service模块中就不能使用，因为引擎没初始化
  
* 写业务功能之前，先把逻辑理顺，先干什么，再干什么，最后干什么

* 查看tomcat日志

  * `tail -2000 all.log`

* 日志`slf4j`

  * 本地调试报错时，如果要看到SQL语句及参数，将Log（Log4j）日志级别改为==Debug模式==
  * `private static final Logger logger = LoggerFactory.getLogger(Abc.class);`
  * 使用占位符`logger.debug("Processing trade with id: {} and symbol : {} ", id, symbol);`
  * 避免重复打印日志，浪费磁盘空间，务必在 log4j.xml中设置 additivity=false，`<logger name="com.taobao.dubbo.config" additivity="false">`

* 异常处理

  * 异常信息应该包括两类信息：案发现场信息和异常堆栈信息。如果不处理，那么通过关键字==throws== 往上抛出`logger.error(各类参数或者对象toString() + "_" +e.getMessage(), e);`

* maven中有GAV配置，但是依赖没下载下来，报错了

  * 到本地maven仓库删除未下载完的依赖文件，然后会自动下载
  
* 将两个byte[]合并到一个新的byte[]

  ```java
  byte[] b = new byte[]{0x00, 0x00, 0x56, 0x04};
  byte[] face = (byte[]) redislistObj.get(houseHolderBean.getFaceId());
  
  byte[] result = new byte[b.length + face.length];
  //把b增加到face之前
  System.arraycopy(b, 0, faceByte, 0, b.length);
  System.arraycopy(face, 0, faceByte, b.length, face.length);
  ```

* 下载文件（可以测试验证下）
  * 获取文件的输入流
  * `IOUtils.copyLarge(文件流, HttpServletResponse.getOutputStream());`
  * `HttpServletResponse.getOutputStream().flush()`
  
* 返回Bean中的属性是个图片文件
  * 如果是本地的，则相对路径作为参数，传入到一个接口中，然后将接口地址及参数作为该Bean的属性返回
  * 如果是其他系统的，如OSS，则返回Http链接
  
* 文件存服务器本地
  * 完整的地址分为两段，更具有灵活性
    * 第一段，在配置文件中配置，从服务器的根目录开始的几层目录
    * 第二段，文件的相对路径，也是存入标中的路径
  
* StringUtils工具类

  ```java
  <dependency>
  	<groupId>org.apache.commons</groupId>
  	<artifactId>commons-lang3</artifactId>
  	<version>3.0</version>
  </dependency>
  
  StringUtils.defaultIfBlank(this.node, "")
  ```

* ==访问报错，第一时间去看服务器上日志==

* ==善于用工具类==

* 尽量避免重复代码，善于封装方法

* boolean在MySQL里的类型为tinyint(1)

  * POJO类中定义成boolean，在mysql中定义成tinyint(1)
  
* 有Oracle时POJO不要用true和false，用0和1

  * 要不然巨坑

* 多表更新

  ```sql
  UPDATE  t1
  LEFT JOIN t2 ON t2.id = t1.id
  SET     t1.col1 = newvalue
  WHERE   t2.id IS NULL
  ```

* 从lov中查找数据（从数据库中），即新增数据时不用重新部署

* ```java
  private static DecimalFormat fnum = new DecimalFormat("##0.00");
  fnum.format(score*100)
  ```

* 分页

  ```java
  @GetMapping("/experiencesissue")
  @ResponseBody
  public Page<QualityIssue> queryExperience(PageQueryBean bean) {
    return service.queryExperience(bean);
  }
  
  public class PageQueryBean extends Page implements Serializable{
    private String startTime;
    private String endTime;
    ...
  }
  
  public class Page<T> implements Serializable{
    private int page;
    @JsonIgnore
    private int startIndex;
    private int size = 10;
    private int totalPages;
    private long count;
    private List<T> data;
    public Page<T> init(List<T> data, long count) {
          this.data = data;
          this.count = count;
          this.totalPages = (int) ((count + size - 1) / size);
          this.page = Math.max(1, page);
          return this;
    }
    @JsonIgnore
    public int getStartIndex() {
      return Math.max(page - 1, 0) * size;
    }
    ...
  }
  
  public Page<QualityIssue> queryExperience(PageQueryBean bean) {
    Page<QualityIssue> result = new Page<>();
    bean.setFormType("experience");
    List<QualityIssue> list = dao.queryExperienceList(bean);
    int count = dao.queryExperienceCount(bean);
    return result.init(list, count);
  }
  ```

  ```sql
  SELECT
  	<include refid="issueDetail"/>
  from t_quality_issue
  where form_type = #{formType}
  <if test="startTime != null and startTime !=''">
  	and create_time &gt;= #{startTime}
  </if>
  <if test="endTime != null and endTime !=''">
  	and create_time &lt;= #{endTime}
  </if>
  order by last_update_time desc
  limit #{startIndex}, #{size}
  
  SELECT
  	count(*)
  from t_quality_issue
  where form_type = #{formType}
  <if test="startTime != null and startTime !=''">
  	and create_time &gt;= #{startTime}
  </if>
  <if test="endTime != null and endTime !=''">
  	and create_time &lt;= #{endTime}
  </if>
  ```

* 上传到服务器本地，从服务器本地下载

  ```java
  // 上传时覆盖相同文件名
  public static void main(String[] args) throws IOException {
    File file = new File("/Users/dingyuanjie/Documents/study/github/22/redis.pdf");
    File dir = new File("/Users/dingyuanjie/Documents/study/github/11/");
    InputStream inputStream = new FileInputStream(file);
    FileUtils.copyInputStreamToFile(
      inputStream,
      new File(dir.getCanonicalPath(), file.getName()));
  }
  ```

* `! [remote rejected] master -> master (pre-receive hook declined)`

  * 权限问题
  
* `BeanUtils`

  ```java
  //相同属性将被复制
  BeanUtils.copyProperties(Object source, Object target);
  ```

* catch多个异常块，只会在一个异常块中处理

* 建表时要加上`create_time`、`last_update_time`、`is_delete`、`create_user`、`last_update_user`

* windows复制

  ```java
  C:\Users\tking\Desktop\war\1> copy D:\env\beijing\**\target\*.war C:\Users\tking\Desktop\war\1
  ```

* oracle表主键自动增长

  ```shell
  --给表设置自增主键
  修改id为自增:id int generated by default on null as identity (start with 10000) primary key

  # 无效字符
  仔细看打印的日志，应该有乱码字符
  表的别名最后一个字符不要和left等连接关键字的第一个字符相同
  ```

* `20170926010203   yyyy-MM-dd HH:mm:ss`

  ```java
  StringBuilder sb = new StringBuilder(str);
  sb.insert(4, "-");
  sb.insert(7, "-");
  sb.insert(10, " ");
  sb.insert(13, ":");
  sb.insert(16, ":");
  ```

* 项目redis启动报错：无法从redis连接池中获取连接，==要看完整的报错信息，不能只看第一条==
  * 项目redis设置密码，所以redis服务器的redis.conf的配置文件中设置相应密码`requirepass qwer6379`
  * 然后指定配置文件redis.conf启动redis服务端
  
* RequestMapping的method缺省

  * 可以处理任何方式的 http method 类型的请求

* 页面查询返回没数据，而把SQL复制出来到数据库查询有数据

  * 连接不同的数据库导致

* 图片与Base64字符串互转

  ```java
  ByteArrayOutputStream os = new ByteArrayOutputStream();
  File file = new File("/Users/dingyuanjie/Documents/work/QAK/png/1.png");
  BufferedImage read = ImageIO.read(file);
  ImageIO.write(read, "png", os);
  // 还原的话，前面加上 data:image/png;base64,
  String s = Base64.getEncoder().encodeToString(os.toByteArray());
  System.out.println(s);
  
  OutputStream out = new FileOutputStream(new File("/Users/dingyuanjie/Documents/work/QAK/png/111.png"));
  byte[] decodeByte = Base64.getDecoder().decode(s);
  ByteArrayInputStream bis = new ByteArrayInputStream(decodeByte);
  BufferedImage img = ImageIO.read(bis);
  //将图片写入指定文件
  ImageIO.write(img, "png", out);
  ```

* Oracle Long型日期与格式化日期互转

  ```sql
  -- Long型日期转格式化日期
  SELECT TO_CHAR(1524013682750 / (1000 * 60 * 60 * 24) +
                 TO_DATE('1970-01-01 08:00:00', 'YYYY-MM-DD HH:MI:SS'), 'YYYY-MM-DD HH:MI:SS') AS CDATE
  FROM DUAL;
  
  -- 格式化日期转Long型日期
  SELECT TO_NUMBER(TO_DATE('2018-04-18 09:08:03', 'YYYY-MM-DD HH24:MI:SS') -
                   TO_DATE('1970-01-01 08:00:00', 'YYYY-MM-DD HH24:MI:SS')) * 24 * 60 * 60 * 1000 as str
  FROM DUAL;
  ```

* `@DateTimeFormat`和`@JsonFormat`

  ```java
  // 将请求参数为yyyy-MM-dd HH:mm:ss类型字符串自动转换为Date类型数据
  @DateTimeFormat(pattern = "yyyy-MM-dd HH:mm:ss")
  private Date startTime;
  
  // 返回给客户端时，Date类型的数据自动转换为14位的字符串返回出去
  @JsonFormat(pattern="yyyy-MM-dd HH:mm:ss",timezone="GMT+8")
  private Date updateTime;
  ```

* for循环中，遇到continue则跳出当次循环，即不继续执行continue下面的代码，开始下次循环

  * 在try中throw new ServiceException()，在catch中处理，不会中断for循环

* controller层报错，提示request、response需要序列化

  * 原因是通过hessian代理来调用service时需要序列化
  * 将涉及request、response的调用移动到controller层
  * 例如文件下载，在controller层处理

* ```java
  org.springframework.remoting.RemoteAccessException: Cannot access Hessian remote service at [http://10.0.0.62:8090/community.manage-service/remote/manage/houseHolderManageService]; nested exception is com.caucho.hessian.io.HessianProtocolException: '￿' is an unknown code
  // Hessian中不要传流                                                                                             
  ```

* 浏览器文件下载

  * 前端最好用`window.open`去调用后端接口下载，不要用ajax
  * 用form提交、`window.location.href`
  * 问题：用ajax下载txt、log等文本文件时会在浏览器里打开而不下载

  ```java
  String fileName = equipmentArea.getG_addr() + "_" + DateUtils.format(new Date(), DateUtils.FORMAT_DATE_YYYY_MM_DD) + ".log";
  String path = ConfigUtil.getUploadDir()+ "/" + FilePathEnum.entrance_machine.getPath() + "/" + fileName;
  //            LocalFileUtils.download(path, response);
  // path是指欲下载的文件的路径。
  File file = new File(path);
  // 取得文件名
  String filename = file.getName();
  // 取得文件的后缀名。
  String ext = filename.substring(filename.lastIndexOf(".") + 1).toUpperCase();
  
  // 以流的形式下载文件。
  InputStream fis = new BufferedInputStream(new FileInputStream(path));
  byte[] buffer = new byte[fis.available()];
  fis.read(buffer);
  fis.close();
  // 清空response
  //            response.reset();
  // 设置response的Header
  response.addHeader("Content-Disposition", "attachment;filename=" + new String(filename.getBytes()));
  response.addHeader("Content-Length", "" + file.length());
  OutputStream toClient = new BufferedOutputStream(response.getOutputStream());
  response.setContentType("application/octetc-download");
  toClient.write(buffer);
  toClient.flush();
  toClient.close();
  ```

* 通过浏览器console查看调用接口
  
* 云对讲框架细节
  
  * 登录、拦截器
  * socketIO
  * hessian
  
* oracle批量插入

  ```xml
  <insert id="saveAttachmentForm" useGeneratedKeys="false" keyColumn="id">
          insert into portal_attachment_form
          (formId,attachmentId,orderNumber,indexName,groupId,company_code,opt_counter,create_time,last_update_time,create_user,last_update_user)
  
          <foreach collection="attachmentForms" item="obj" index="index"
                   separator=" union all ">
              select #{obj.formId} as formId,
                     #{obj.attachmentId} as attachmentId,
                     #{obj.orderNumber} as orderNumber,
                     #{obj.indexName} as indexName,
                     #{obj.groupId} as groupId,
                     #{companyCode} as companyCode,
                     1,
                     sysdate as sysdate1,
                     sysdate as sysdate2,
                     #{requestUser} as requestUser1,
                     #{requestUser} as requestUser2
              from dual
          </foreach>
      </insert>
  ```

* 即使前端传字符串，后端startTime和endTime定成Date类型，可以在接收之前将字符串类型转为Date类型，然后时间之间可以直接比较大小

* Linux目录文件查找

  * `ls -lh *.log`

* 日期

  ```java
  TO_CHAR(tu.u_createdate,'YYYY-MM-DD HH24:MI:SS') as submitTime
  and	homs.create_time &gt;= to_date(#{startTime}, 'yyyy-mm-dd hh24:mi:ss')
  ```

* 对系统外传入的数据，如时间，要进行格式校验

* 浏览器下载文件

  ```java
  //普通文件下载
  File file = new File(ConfigUtil.getUploadDir()+FilePathEnum.entrance_machine.getPath()+"/" + bean.getUploadName());
  byte[] videoBytes = FileUtils.readFileToByteArray(file);
  
  response.addHeader("Content-Disposition", "attachment;filename=" + new String(bean.getUploadName().getBytes()));
  response.addHeader("Content-Length", "" + videoBytes.length);
  OutputStream toClient = new BufferedOutputStream(response.getOutputStream());
  // video/mpeg4
  response.setContentType("application/octetc-download");
  toClient.write(videoBytes);
  toClient.flush();
  toClient.close();
  ```

  ```java
  //压缩下载
  ByteArrayOutputStream baos = new ByteArrayOutputStream();
  ZipOutputStream zos = new ZipOutputStream(baos);
  String[] files = {"/Users/dingyuanjie/Downloads/8O1Ry_2019-06-13_11-40-57_200902041905170024.mp4","/Users/dingyuanjie/Downloads/EGuXK_2019-06-13_11-36-58_200902041905170024.mp4"};
  for (String fileName : files) {
    // 名字可以自定义，但是要带上后缀名
    zos.putNextEntry(new ZipEntry(fileName.substring(29,35) + ".mp4"));
    zos.write(FileUtils.readFileToByteArray(new File(fileName)));
    zos.closeEntry();
  }
  zos.flush();
  baos.flush();
  zos.close();
  baos.close();
  
  ServletOutputStream sos = response.getOutputStream();
  response.setContentType("application/zip");
  response.setHeader("Content-Disposition", "attachment; filename=" + "111.zip");
  
  sos.write(baos.toByteArray());
  sos.flush();
  ```

* oracle中，标中FILE字段与系统保留字FILE冲突
  
  * 使用时，双引号包裹FILE，如"FILE"
  
* 异步执行

  ```java
  @Configuration
  @EnableAsync
  public class SpringAsyncConfig {
      @Bean(name = "asyncTaskExecutor")
      public TaskExecutor specificTaskExecutor() {
          ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
          executor.setThreadNamePrefix("asyncTasks-");
          Integer asyncTaskThreadSize = ConfigUtil.getIntValue("asyncTaskThreadSize", 20);
          if (asyncTaskThreadSize != null) {
              executor.setCorePoolSize(asyncTaskThreadSize);
              executor.setMaxPoolSize(asyncTaskThreadSize);
          }
          executor.initialize();
          return executor;
      }
  }
  ```

  ```java
  // 调用方法和实现方法不能在同一个类中
  @Service
  public class AsyncTestServiceImpl implements AsyncTestService {
    	@Async("asyncTaskExecutor")
      @Transactional(propagation = Propagation.REQUIRES_NEW, rollbackFor = Exception.class)
      @Override
      public void processData(JSONObject jsonData){
        logger.info("当前线程为................{}", Thread.currentThread().getName());
        ...
      }
  }
  
  public interface AsyncTestService{
    void processData(JSONObject jsonData);
  }
  ```

* maven 依赖红色波浪线报错，打包报错，提示某版本的包不存在
  * 添加相应的版本包