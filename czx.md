1.socket的了解：

​    服务端ServerSocket   类，IP  和  端口暴露  



​     服务端关键方法：socket=serverSocket.accept();// 监听,等待连接,一旦有client端连接便创建socket实例.然后通过socket交互数据.如果把监听写进while()循环里便可实现不断的监听。

​     	数据接收和发送基于socket套接字流：socket.getOutputStream()  和  socket.getInputStream()



   多个客户端聊天基于socket的实现思路：



​    user 类封装： 关键属性   socket 

​    

​     服务端收到消息，把user封装一下，发送时候指定发送到那个user，

服务端对信息解析，收到A发送B的信息，使用B的socket管道去发送信息。



socket的长连接和短连接。  长时间连接和短时间连接呗，大多数是已流是否关闭。一般长连接适合点对点的聊天。短连接一般一对多直接的连接。



2.webservice技术

​      四点：

​      1.基于SOAP协议，简单对象访问协议，主要和http协议+XMl文档

​       2.wsdl  webservice描述语言

​       3.UDDI   统一描述、发现和整合规范。用来注册和查找服务，把web services收集和存储起来，这样当别人访问这些信息的时候就从UDDI中查找，看有没有这个信息存在



主要使用的框架是CXF去发布服务：





3.http协议



   get  请求  和  post 请求区别：

1.get请求 请求参数会显示在地址栏中  不安全

​       post请求 地址栏只显示请求资源的url 不显示请求参数 相对安全

2.get请求 请求参数存放在请求首行中  http对请求首行限制1kb

​       post请求  请求参数存放在请求体中  请求体没有大小限制

  post可以发送大数据

3.post比get慢 

4.post用于修改和写入数据，get一般用于搜索排序和筛选之类的操作（淘宝，支付宝的搜索查询都是get提交），目的是资源的获取，读取数据 





http 和 https 协议区别

HTTPS是HTTP协议的安全版本，HTTP协议的数据传输是明文的，是不安全的，HTTPS使用了SSL/TLS协议进行了加密处理。







JVM方面问题：



调优需要了解的命令：

**jstack ( 查看jvm线程运行状态，是否有死锁现象等等信息) : jstack pid : thread dump** 



**jconsole是一个用java写的GUI程序，用来监控VM，并可监控远程的VM，非常易用，而且功能非常强。使用方法：命令行里打 jconsole，选则进程就可以了**



**jps****:与unix上的ps类似，用来显示本地的java进程，可以查看本地运行着几个java程序，并显示他们的进程号。** 



**jmap是一个可以输出所有内存中对象的工具，甚至可以将VM 中的heap，以二进制输出成文本。**



**jinfo****:可以输出并修改运行时的java 进程的opts。**



**JMM模型：**

<http://www.mamicode.com/info-detail-1028149.html>



JAVA代码编译和执行过程:



- Java源码编译机制
- 类加载机制
- 类执行机制



编译只要是java文件编译称二进制的class文件。

编译主要分三步：分析输入和符号表，注解加载处理，语义分析和生成class文件。



类加载机制：

类加载机制是由classloader及其子类完成类加载的过程.

\1. BootStrap   Classloader

​    负责加载java_home中jre/lib/rt.jar  里面的class，由c++实现，不是classloader子类



\2. Extension   Classloader  

​    负责加载java平台中拓展功能的一些jar包



\3. App  Classloader

   负责加载classpath中的jar，以及目录中的class



4.custom classloader



加载过程是从低到顶，逐层检查，只要某个classloader已加载就视为已加载了此类。保证此类只被classloader加载一次。



类执行机制：

JVM的类执行机制就是基于栈来执行class字节码的，线程创建后，就会生成程序计数器和栈。



类加载中有双亲委派机制，双亲委派机制的大致意思是一个类加载器收到加载一个类的请求，他会首先委托父类去加载，若是父类还存在父类，一直向上委托。这样做的好处是避免了重复加载，第二每个类的只会被同一个类加载器加载。第三防止危险代码的植入。



**JVM内存管理和垃圾回收**



jvm的内存组成结构主要由，堆，栈，本地方法栈，方法取组成。



从对象内存是否线程共享来划分：堆区和方法取的线程共享，举个例子就是可以用synchorinize来锁的对象。  栈区的对象是线程独有的。



堆区：所有new出来的对象在堆区。对大小设置我们可以通过-xmx 和  -xms 设置最大堆内存和初始堆内存。堆区又分为新生代和老年代，默认比例是1;2,其中新生代有划分为Eden，From Survivor、To Survivor 默认比例为8:1:1.  这样做的目的是为了更高的管理内存，也就是内存分配和内存回收。



栈：每个线程执行每个方法的时候都会在栈中申请一个栈帧，每个栈桢包括局部变量和操作数栈。用于存放此次方法执行的临时参数，参数和中间结果。-xss：设置线程栈的大小，jdk1.5之后，默认是1M，本地方法栈主要用来执行native的本地方法。



方法区：存放要加载的类信息，静态变量，final修饰的属性，方法，常量信息。JVM使用持久带来存放方法区，可以使用-XX:permsize  和 -XX：MaxPermsize来指定最小值和最大值。



垃圾回收算法:



1.引用计数

​    比较古老的算法。原理对象有一个引用就增加一个计数，删除一个引用就减少一个计数，只用收集计算为0的对象。缺陷在于不能处理循环引用的情况。



2.标记清除

​    此算法分两阶段，标记所有的引用了的对象，然后清除所有没有被引用的对象。

缺陷在于要暂停整个应用，会产生内存碎片。



3.复制

​    此算法就是把内存空间划分为两个相等区域，每次只使用一个区域，垃圾回收时候，遍历当前使用的区域，把正在使用的复制到另一个区域，复制之后会进行内存整理，所以不会出现内存碎片，缺陷是，需要两倍的空间。



4.标记整理

​    标志整理其实是标记清除的一个升级，先标记引用的对象，然后清除未标记的对象同时对存活的对象进行整理，避免的碎片。



在jvm中对于新生代和老年代采用的是不同的回收算法。



新生代存活时间短，所以是基于复制算法来进行垃圾回收的。



老年代是基于标记算法来垃圾回收的。



在执行机制上jvm提供了串行，并行 和 并发三种执行机制。



JVM内存调优：

调优的主要目的有方向，减少GC的频率和FUll GC的次数。过多的gc和full  gc会占用系统的cpu



full gc常常出现的情况：

老年代内存不足：方案，尽量让对象在新生代被gc回收或者在新生代多存活一些时间。



控制新生代和老年代比例。



持久带内存不足：

 增加permsize的空间，避免太多静态变量。



一般调优的方式是：

各个部分的比例和GC策略来实现



设置不当会有一下问题：

新生代设置过小：

一是新生代gc频繁，二是新年代会直接到老年代，触发full gc



新生代过大：

老年代内存不足，会增大full gc的次数



**Survivor设置过小**

**减少了新生代到老年代的时间，增大了full gc频率**



**Survivor设置过大**

**导致eden变小，增加了gc频率。**









分布式系统的CAP理论

理论首先把分布式系统中的三个特性进行了如下归纳：

● 一致性（C）：在分布式系统中的所有数据备份，在同一时刻是否同样的值。（等同于所有节点访问同一份最新的数据副本）

● 可用性（A）：在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求。（对数据更新具备高可用性）

● 分区容错性（P）：以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择。









**BASE**是下面三个术语的缩写：

- 基本可用（Basically Available）
- 软状态（Soft state）
- 最终一致（Eventually consistent）











http的组成，tcp的三次握手过程，为啥不是二次握手，四次挥手过程。（画图）



mysql的三方式，脏读，幻读可重复读。

b加树的结构叶子节点是否存储数据。





lock和synchronize区别





Kafka相对其他mq的优势.





hbase主键建立规则



注入的三个注解以及区别



一个单机的利用多线程去跑一个任务，启动多少个线程好呢？



链表的种类，单链表  ，双向链表，循环链表的区别，Arraylist和原生的数组区别在哪呢？



redis缓存雪崩的解决方案



线程池的ExecutorService的shutdown() 和 shutdownNow()的区别。



lambda表达式的了解



zk的选举机制



mq会不会存在消息丢失情况，重复消费情况。有如何解决？



设计模式的设计原则的了解



Synchronize去锁static 属性和非static属性的区别。



spring的四种隔离级别



MyBaits 和 herbinate 的区别





如果一台机器的内存是8G，你会给redis内存设计几个G呢？

redis在做持久化的时候内存会是两倍，所以设置成4G比较好



JVM的调优过程，-XMS  和 -XMX 内存设置成一样，会产生什么影响呢？

JVM初始分配的内存由-Xms指定，默认是物理内存的1/64；JVM最大分配的内存由-Xmx指 定，默认是物理内存的1/4。默认空余堆内存小于40%时，JVM就会增大堆直到-Xmx的最大限制；空余堆内存大于70%时，JVM会减少堆直到 -Xms的最小限制。因此服务器一般设置-Xms、-Xmx相等以避免在每次GC 后调整堆的大小。



GC回收，如果A引用了B，没有标记A的引用，但是标记了B的引用，A会被回收吗？

会被回收，jvm使用的是可达性算法，而不是古老的引用计数算法。

引用链是个树形结构，以GC Roots为起点向下搜索，所走过的路径就是引用链，当发现一个对象和GC Roots间没有任何引用链，那么这个对象就是不可用的，应该被GC。



JAVA的泛型使用的是强泛型还是弱泛型？

java的泛型是编译期的一种行为校验，泛型提高了代码的可拓展性，一般情况下，我们可以使用object类型代替，但是使用泛型可以避免强制类型转换，还可以限定一些情况（<T extends number>）限定泛型的范围。同时编译器进行数据检验，避免了运行期出现castException异常。泛型的实现使用的是擦除机制，在擦除之后保留原始数据类型，比如object或者指定的继承的数据类型。所以说，为什么泛型可以限定类型方法呢，这是编译的手段，先检查，再编译，然后运行。反正类类型转换异常，这点的考证可以使用反射来实现，比如ArrayList<Integer>  list; list.get(0).add("123")//会报错，但是我们使用反射调用add方法添加字符串就不会报错，证明编译时候并不是Integer类型。

java中的泛型是弱泛型。



线程数据共享有哪些方式？

这道题的答案我觉得是如何实现数据共享的具体过程，可以用两种方式1：将共享的数据作为一个对象的属性，然后将这个对象分发给每个线程 2：共享数据作为成员变量，然后添加一个runable的内部类。	每个线程对runable的操作都放在外部类中。







http协议通信过程是明文，内容可能被窃听.通信过程中不验证通信双方的身份.无法验证报文的完整性.

https 使用明文加密，非对称加密算法.



对称加密和非对称加密.维护一个密钥key，密钥加密，密钥解密



非对称加密  公钥加密，私钥解密。公钥由服务端算法随机发放到客户端，私钥解密。





http的主要组成是http请求和http响应。





请求分为三部分，状态行，请求头，请求正文。

状态行就是请求方法，协议版本，资源路径.

请求头：访问域名，代理和cookie信息

请求正文：就是http请求发送的数据



hhtp响应：状态行，响应头，响应正文。

状态行：状态码，协议版本

状态码常见的有，3 xx  是重定向问题。

301 永久重定向  302 临时重定向 304 重定向本地缓存。4xx 客户端问题  403 请求被服务端拒绝 404 服务端不存在url  5xx服务端问题  500 服务端永久出错  503 服务端临时出错。

响应头：数据格式，响应时间

响应正文：响应的返回数据。



重定向和转发的区别：

从地址上来说，转发是服务端直接访问URL读取数据返回给客户端，而重定向是服务器发送一个状态码，告诉浏览器去访问新的url地址。所以转发地址不变，重定向url会发生变化。

从数据共享来说，请求页面到转发页面数据是共享的。

重定向的request数据不共享。





三次握手的过程：

第一次握手：客户端向服务端发送一个syn包到服务端，并进入syn  send的状态

第二次握手：服务端收到syn包，然后确认客户端的syn，同时自己也发送一个sync包，即发送sync+ack包，并进入syn recv状态

第三次握手：客户端收到服务端sync+ack包，并发送服务端ack确认。此时客户端和服务端都变成established装态。



为啥不能二次握手呢？

二次握手会存在问题，消息通道不可信！二次握手后，假设客户端发送a1包，由于链路眼神，服务端未给回应，会重发一个a2包，但此时a1包到了服务端并给出一个ack回应a1，但此时客户端已经丢失了a1包。二次握手会会浪费服务端资源。



四次挥手的过程：

1.客户端主动发送释放连接报文，发送FIN和seq=u序号，进入FIN_WAIT_1状态

2.服务端收到消息，发出确认ACK 和seq=u+1，自身发个seq=v，进入CLOSE_WAIT，

   此时客户端收到确认消息后状态会变成FIN_WAIT2,然后等待服务的确认关闭消息

3.服务端向客户端发出数据，FIN ，ACK ，Seq，状态变为LAST_ACK

4.客户端发送报文FIN，ack，seq，A进入TIME_WAIT状态，服务端变成CLOSED状态，而过2s后客户端变成CLOSED状态。











脏读：两个事物不隔离，一个事物修改了数据，未提交数据，另一事物读取了数据，此时就是脏读。



不可重复读：两个事物一起执行，一个事物开始查数据，然后另一个事物更新数据，然后之前事物再读取数据不一样了。



幻读：两个事物，一个事物插入了一条数据，另一个发现数据多了一条。出现幻读。



对于默认的可重复读隔离级别是在同一个事务中仅仅读取，同一次事务的结果是一样的。



三者区别：脏读是事物未提交。读了脏数据。不可重复读和幻读是事物提交了，不可重复读是数据修改update操作，幻读是数据插入insert出现幻读。







数据库三范式：

1:字段不可再分

2:有主键，非主键字段依赖主键字段

3:每列与主键都有直接关系，不存在传递依赖





lock是接口，synchronized是关键字。

lock必须主动调用unlock释放锁，synchronized是由monitor exit自动释放锁。



lock可以让等待线程中断，sync不行。lock可以知道线程是否获取了锁，sync不行



从性能上说，两者差不多。lock 可以实现公平锁.  



所谓的公平锁就是尽量以请求锁的顺序去获取锁。当一个线程结束，最先请求的获取锁。



注入的三个注解是：

**@Autowired、@Inject、@Resource三者区别**



**@Autowired**

**Spring 框架定义的注解  ，默认是根据类型去配置的，如果有多个类型，则会报错。**

**可以结合@Qualifier使用通过名称去获取。**



**@Inject**

**是java提供的注解，根据类型去匹配，配合@Name可以实现根据名称装配**



**@Resource**

**是java提供的注解，根据名称去匹配，一般会指定name属性。**



**启动线程数目控制：**

如果是CPU密集型的任务，我们应该设置数目较小的线程数，比如CPU数目加1。如果是IO密集型的任务，则应该设置可能多的线程数，由于IO操作不占用CPU，所以，不能让CPU闲下来。



线程数量设置公式：最佳线程数目 = （线线程等待时间与程CPU时间之比 + 1）* CPU数目



线程等待时间 即可认为是磁盘IO过程，线程CPU时间是线程计算的时间。



链表：

单链表结构： 单链表 是数据域和一个指针域，最后一个指针域的节点指向NULL

双链表结构： 双链表 有数据域和两个指针域，一个pre和next，pre指向前一个节点，next指向后一个节点，末尾的next指针指向NULL。

循环链表：单循环链表和双循环列表。末尾指向NULL的指针域改成指向第一个节点。



LinkList的底层实现实双向循环链表，双向循环链表的好处是可以首尾查询快，主要的参数有三个，

transient int size = 0;  

transient Node<E> first;  //头节点

transient Node<E> last;  //尾节点



ArrayList和原始数组的最大区别是在于实现了数组的动态扩容。ArrayList默认的数组长度是10.



ArrayList  和  LinkedList的区别，本人觉得应该从三个函数去讨论它们的优劣。



get(int i)   ,  add（E e） ，set(int index n)



get上Arraylist 快，  add上差不多效率，大数据量插入Arraylist快，set上LinkedList快。



1.缓存失效后，通过加锁或者队列来控制请求数据库的线程数。

2.可以使用reload机制，预估在大并发请求来之前，手动去触发重新加载缓存。

3.不同的key，设置不同过期时间，让缓存失效尽量均匀。

4.做二级缓存，设置双缓存的机制，一级缓存为主缓存，二级为拷贝缓存，一级可以设置时间短一些，二级缓存时间长一些。



ExecuteService



shutdown 不在接受新的线程，等待已经执行的线程执行完之后关闭。

List<Runnable>   shutdownnow  直接关闭活跃状态的所有的线程 ， 并返回等待中的线程。

返回值不同



java8之后的lamda表达式，对于Stream流做了很多懒运算，提供了大量的函数。

ArrayList<Integer> list= new ArrayList<>();

list.add(5);

list.add(4);

list.add(10);

list.add(3);

list.add(2);

List list1 = list.stream().filter(item->item>5).collect(Collectors.toList());





消息丢失的问题主要是由于异步非持久化的消息出现问题，但一个消息阻塞情况下，内存不够会释放内存，删除消息



消息重复是由于客户端收到了消息，并不有给服务端一个ack的确认，消息就会重复，例如事务没有commit，在非事务情况下，批量确认情况下，没有确认。消息超过重复次数会进入死信队列。解决消息重发可以通过幂等运算



对于Synchronize   使用在方法区还是堆区，这两个一个是锁的类，一个锁的是对象的实例。

这两个锁是没有互斥关系的，是不同对象。如一个statis 方法上加synchronize 和 一个非statis修饰的方法上加Synchronize，这两个方法不是用的同一把锁，这两个方法直接也就不会有互斥关系。



设计模式的原则，也就是OOP的原则有以下几种：

单一原则：一个类尽量干一件事，如果能干两件事，能分开成独立两个类就分成两个类。



开放封闭原则：类，模块，函数，可以去拓展，尽量不要去修改。主要实现就是继承或者是组合来拓展类，而不是直接修改代码。Spring中的beanWarpper就是通过反射和代理方式去重新生成一个对象，而不是对原有类的修改。



里式替换原则： 父类可以存在的地方，子类一定可以存在，父类可以被子类替换。



最少知识原则：减少对象之间的依赖，通常来说就是低耦合，高内聚。



接口隔离原则：不要对外暴露没有实际意义的接口



依赖倒置原则：面向接口编程，抓住事务共同点。



Spring有四种事务特性（ACID）五种隔离级别和七种事务传播行为

Spring的隔离级别：

spring的隔离级别默认是后台数据库设置的隔离级别，也可以自己设置未提交读，提交读，可重复读和串行读的隔离级别。

Spring的事务的传播特性总共有以下7种：

PROPAGATION_REQUIRED 支持当前事务，如果不存在 就新建一个(默认) 





1.herbinate 是全自动的，Mybaitis是半自动的。

   javaBean 完全可以通过对象模型来对数据库操作，也就是HQL语言。而Mybaits是有基本的字段映射，对象数据以及对象实际关系需要sql来实现管理。



2.herbinate的数据库的可移植性远优于Mybatis。

   因为herbinate是基于hql语言开发的话。和数据的耦合性就降低了。对于数据库是mysql还是oracle就没有太大影响了。



3.herbinate 拥有完整的日志系统，mybaits略差一些



4.对于复杂的sql语句，mybaits 比 herbinate 方便优化。



5.herbinate支持二级缓存















































































































​    