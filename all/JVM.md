# MS

- 说一下java堆的空间结构，常用的jvm内存分析命令及工具
  - JVM调优的常见命令工具包括：
    1. jps显示当前运行的java进程
    2. jstat用于监控虚拟机各种运行状态信息
       - jstat查看gc实时执行情况
         - ` jstat -gc 12538 5000`
         - 每5 秒一次显示进程号为 12538的 java进成的 GC情况
    3. jinfo用于查询当前运行JVM的属性和参数的值`jinfo [option] <pid>`
    4. jmap用于打印指定Java进程的共享对象内存映射或堆内存细节
       - jmap查看各个代的内存使用
         - `jmap -heap pid `
         - `jmap -heap 2083`
    5. jhat用于分析使用jmap生成的dump文件，是JDK自带的工具
    6. jstack用于生成java虚拟机当前时刻的线程快照，可通过线程快照分析线程问题，例如死锁，死循环等`jstack [-l] <pid> (连接运行中的进程)`
  - java内存溢出问题你们是怎么排查的
    - 抓取对应pid的dump文件
      - `kill -3 <pid>`
      - 当使用 `kill -3` 生成 dump 文件时，dump 文件会被输出到标准错误流。假如你的应用运行在 tomcat 上，dump 内容将被发送到`<TOMCAT_HOME>/logs/catalina.out`文件里
    - 然后用 Profiler 工具
  - 图形化工具：
    - jconsole：一个java GUI监视工具，可以以图表化的形式显示各种数据。并可通过远程连接监视远程的服务器VM
    - jvisualvm
  - JVM常见的调优参数包括：
    1. -Xmx：指定java程序的最大堆内存, 使用java -Xmx5000M -version判断当前系统能分配的最大堆内存
    2. -Xms：指定最小堆内存, 通常设置成跟最大堆内存一样，减少GC
    3. -Xmn：设置年轻代大小。整个堆大小=年轻代大小 + 年老代大小。官方推荐配置为整个堆的3/8
    4. -Xss：指定线程的最大栈空间, 此参数决定了java函数调用的深度, 值越大调用深度越深, 若值太小则容易出栈溢出错误(StackOverflowError)
    5. -XX:PermSize：指定方法区(永久区)的初始值,默认是物理内存的1/64， 在Java8永久区移除, 代之的是元数据区， 由-XX:MetaspaceSize指定
    6. -XX:MaxPermSize：指定方法区的最大值, 默认是物理内存的1/4， 在java8中由-XX:MaxMetaspaceSize指定元数据区的大小
    7. -XX:NewRatio=n：年老代与年轻代的比值，-XX:NewRatio=2, 表示年老代与年轻代的比值为2:1
    8. -XX:SurvivorRatio=n：Eden区与Survivor区的大小比值，-XX:SurvivorRatio=8表示Eden区与Survivor区的大小比值是8:1:1，因为Survivor区有两个(from, to)
- Serial 与 Parallel GC之间的不同之处？
  - 在GC执行的时候都会引起 stop-the-world。
  - 它们之间主要不同 serial 收集器是默认的复制收集器，执行 GC 的时候只有一个线程，而 parallel 收集器使用多个 GC 线程来执行
- Java 中 WeakReference 与 SoftReference的区别？
  - 虽然 WeakReference 与 SoftReference 都有利于提高 GC 和 内存的效率
  - 但是 WeakReference没有任何引用时就会被GC回收，软引用可以延迟到 JVM 内存不足的时候
- WeakHashMap 是怎么工作的
  - WeakHashMap 的工作与正常的 HashMap 类似，但是使用弱引用作为 key，意思就是当 key 对象没有任何引用时，key/value 将会被回收
- JVM 选项 -XX:+UseCompressedOops 有什么作用？为什么要使用？
  - 当你将你的应用从 32 位的 JVM 迁移到 64 位的 JVM 时，由于对象的指针从 32 位增加到了 64 位，因此堆内存会突然增加，差不多要翻倍。这也会对 CPU 缓存（容量比内存小很多）的数据产生不利的影响。因为，迁移到 64 位的 JVM 主要动机在于可以指定最大堆大小，通过压缩 OOP 可以节省一定的内存。通过 -XX:+UseCompressedOops 选项，JVM 会使用 32 位的 OOP，而不是 64 位的 OOP
- 怎样通过 Java 程序来判断 JVM 是 32 位 还是 64 位？
  - 可以检查某些系统属性如 sun.arch.data.model 或 os.arch 来获取该信息
    - `System.getProperty("sun.arch.data.model")`
  - java -d32、java-d64
- 32 位 JVM 和 64 位 JVM 的最大堆内存分别是多数？
  - 理论上说上 32 位的 JVM 堆内存可以到达 2^32，即 4GB，但实际上会比这个小很多
  - 64 位 JVM允许指定最大的堆内存，理论上可以达到 2^64
- 解释 Java 堆空间及 GC
  - 当通过 Java 命令启动 Java 进程的时候，会为它分配内存。内存的一部分用于创建堆空间，当程序中创建对象的时候，就从堆空间中分配内存。
  - GC 是 JVM 内部的一个进程，回收无效对象的内存用于将来的分配
- 能保证 GC 执行吗
  - 不能，虽然可以调用 System.gc() 或者 Runtime.gc()，但是没有办法保证 GC 的执行
- 怎么获取 Java 程序使用的内存？堆使用的百分比
  - 可通过 java.lang.Runtime 类中与内存相关方法来获取最大堆内存、总内存及剩余内存。
  - Runtime.maxMemory() ：java虚拟机能从操作系统那里挖到的最大的内存，以字节为单位，如果在运行java程序的时候，没有添加-Xmx参数，那么就是64兆
  - Runtime.totalMemory() ：java虚拟机现在已经从操作系统那里挖过来的内存大小
  - Runtime.freeMemory() ：挖过来而又没有用上的内存
    - ==`Runtime.getRuntime().freeMemory()`==
- Java 中堆和栈有什么区别
  - JVM 中堆和栈属于不同的内存区域，使用目的也不同。
    - 栈常用于保存方法帧和局部变量，而对象总是在堆上分配。
    - 栈通常都比堆小，也不会在多个线程之间共享，而堆被整个 JVM 的所有线程共享

# JVM原理

* JVM本身是介于Java编译器和操作系统之间的程序，提供了一个无视操作系统和硬件平台的Java运行环境
  * 能将字节码转换成机器能够识别的机器码

  * 内存管理

## Java内存区域的分配

- 按线程是否共享分为以下区域

  - 所有线程共享的数据区：
    1. 方法区（JVM规范中的一部分，不是实际的实现）:存储每一个类的结构信息
    
       * Java7时由永久代实现
         * 主要存放元数据，例如Class、Method的元信息，与垃圾回收要回收的Java对象关系不大。相对于新生代和年老代来说，该区域的划分对垃圾回收影响比较小
       * Java8时由元空间实现
         * 元空间并不在虚拟机中，而是使用本地内存，并且大小可以是自动增长的，这样减少了OOM的可能性
    
       * 运行时常量池、方法数据、静态变量、构造函数和普通方法的字节码、JIT编译后的代码
       * 没有要求使用垃圾回收因为回收效率太低
       * 运行时常量池：存放编译器生成的各种字面量和符号引用，在类加载后放到运行时常量池中
    
    2. 堆区：最大的一块区域，是大部分对象、数组分配内存的区域
    
       * 没有限制只能将对象分配在堆，所以出现逃逸分析的技术
  - 每个线程都会有一块私有的数据区：
    1. 虚拟机栈：虚拟机栈与线程同时创建，每个方法在执行时在其中创建一个栈帧，用于存储局部变量表（基本数据类型和对象引用）、操作数栈、方法返回地址。
       * 正常调用完成后恢复调用者的局部变量表、操作数栈、递增程序计数器来跳过刚才执行的指令，或抛出异常不将返回值返回给调用者
    2. 本地方法栈：功能与虚拟机栈相同，为native方法服务
    3. 程序计数器：当前线程所执行的字节码的行号指示器。
       * 唯一一个没有内存溢出的区域。
       * 在虚拟机的概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令
         * 分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器完成。
         * 为了线程切换后能恢复到正确地执行位置，每条线程都需要有一个独立的程序计数器

- 以HotSpot虚拟机实现为例，Java8中内存区域如下：

  - 虚拟机数据区
    - 共享：
    - 堆
    - 不共享：
      - 本地方法栈、程序计数器、虚拟机栈
  - 本地内存区域
    - 共享：
      - 元空间：方法区的实现
        - Java7以及之前是使用的永久代来实现方法区，大小是在启动时固定的
        - Java8中用元空间替代了永久代，元空间并不在虚拟机中，而是使用本地内存，并且大小可以是自动增长的，这样减少了OOM的可能性
          - 元空间存储JIT即时编译后的native代码
      - 直接内存：非Java标准，是JVM以外的本地内存

- 常量池：Java7之后运行时常量池从方法区移到堆区，为Java8移除永久带的做好准备

## Java对象不都是分配在堆上

- 逃逸分析

  - 逃逸是指在某个方法之内创建的对象除了在方法体之内被引用之外，还在方法体之外被其它变量引用到；
  - 后果是在该方法执行完毕之后，该方法中创建的对象将无法被GC回收
    - 由于其被其它变量引用，由于无法回收，即称为逃逸。
- 逃逸分析技术可以分析出某个对象是否永远只在某个方法、线程的范围内，并没有“逃逸”出这个范围，逃逸分析的一个结果就是对于某些未逃逸对象可以直接在栈上分配提高对象分配回收效率，对象占用的空间会随栈帧的出栈而销毁

## 类加载机制

* 虚拟机的类加载机制
  * 虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型
* 类型的加载、连接和初始化过程都是在程序运行期间完成的
  * 提供高度的灵活性，天生可以动态扩展的语言特性就是依赖运行期动态加载和动态连接

- 加载过程
  1. 加载：获取来自任意来源的字节流并转换成运行时数据结构，生成Class对象
  
  2. 验证：验证字节流信息符合当前虚拟机的要求，防止被篡改过的字节码危害JVM安全
  
  3. 准备：为类变量分配内存并设置初始值
  
  4. 解析：将常量池的符号引用替换为直接引用
     
     * 符号引用是用一组符号来描述所引用的目标，直接引用是指向目标的指针）
     
     * 解析阶段在某些情况下可以在初始化阶段之后再开始——为了支持Java语言的运行时绑定
     
  5. 初始化：类变量赋值、静态语句块、执行类构造器
  
- ClassLoader
  - 用来动态加载class⽂件到内存当中
    - 程序在启动的时候，并不会一次性加载程序所要用的所有class文件，而是根据程序的需要，通过Java的类加载机制(ClassLoader)来动态加载某个class文件到内存当中的，从而只有class⽂件被载⼊到了内存之后，才能被其它class所引用
  
- ClassLoader和Class.forName的区别
  - 都是用来对类（类的全限定名称）进行加载，将.class文件加载到jvm中，但是ClassLoader不会对类进行初始化
    - Class.forName还会对类进行解释，执行其static块（静态代码块和静态成员变量被静态方法赋值），包括加载-连接（验证、准备、解析）-初始化
    - 而ClassLoader只有在newInstance时才执行static块，只是加载，newInstance时才连接、初始化
  
- 类加载器
  - 启动类加载器
    - 用C++语言实现，是虚拟机自身的一部分，它负责加载 <JAVA_HOME>/lib路径下的核心类库，无法被Java程序直接引用 
  - 扩展类加载器
    - 用Java语言实现，它负责加载<JAVA_HOME>/lib/ext目录下或者由系统变量-Djava.ext.dir指定位路径中的类库，开发者可以直接使用
  - 系统类加载器
    - 用Java语言实现，它负责加载系统类路径ClassPath指定路径下的类库，开发者可以直接使用
  
- JVM虚拟机认为，两个类相等的条件是

  - 来源于同一个Class文件且被同一个虚拟机加载

- 自定义类加载器
  - 如果不想打破双亲委派模型，那么只需要重写findClass方法即可
  - 如果想打破双亲委派模型，那么就重写整个loadClass方法
  
- 双亲委派
  - 如果最顶层的父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载
  - 优点
    - Java类随着它的类加载器一起具备了一种带有优先级的层次关系，可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。
    - 其次防止恶意覆盖Java核心API
  
- 三次大型破坏双亲委派模式的事件：
  1. 在双亲委派模式出来之前，用户继承ClassLoader就是为了重写loadClass方法（破坏双亲委派模式），但双亲委派模式需要这个方法，所以1.2之后添加了findClass供以后的用户重写。
  2. 如果基础类要调回用户的代码，如JNDI/JDBC需要调用ClassPath下的自己的代码来进行资源管理，Java团队添加了一个线程上下文加载器，如果该加载器没有被设置过，那么就默认是应用程序类加载器
  3. 为了实现代码热替换，OSGi是为了实现自己的类加载逻辑，用平级查找的逻辑替换掉了向下传递的逻辑。但其实可以不破坏双亲委派逻辑而是自定义类加载器来达到代码热替换
  
- 立即初始化类的情况
  - 创建类的实例时，如new，但是通过数组定义来引用类，不会触发此类的初始化`SuperClass[] sca = new SuperClass[10]`
  - 初始化一个类时，如果其父类还没初始化，则需先触发其父类初始化（接口有所不同，只有在真正使用到父接口的时候才会初始化）
  - 调用某个类的静态⽅法
  - 使用反射⽅式来强制创建某个类或接口对应的java.lang.Class对象
  - 当虚拟机启动时会初始化一个要执行的主类（包括main方法的那个类）
  
- 通过子类引用父类的静态字段，不会导致子类的初始化，只会触发父类的初始化（对于静态字段，只有直接定义这个字段的类才会被初始化）

## 内存分配（堆上的内存分配）

* 堆
  * 新生代
    * 进入条件
      * 大多数对象在新生代中被创建，其中很多对象的生命周期很短，每次新生代的垃圾回收（又称Minor GC）后只有少量对象存活，所以选用复制算法，只需要少量的复制成本就可以完成回收
    * Eden
      * 大部分对象在Eden区中生成
      * 当eden快要满了时会进行第一次Minor GC回收（只回收eden区），回收不了的会分配到s0区，当eden快满的时候就行第二次Minor GC回收（回收eden和S0区），当S0满了时，此区的存活且不满足“晋升”条件的对象将被复制到另外一个S1区
        * 对象每经历一次Minor GC，年龄加1，达到“晋升年龄阈值”后，被放到老年代
        * 在Serial和ParNew GC两种回收器中，“晋升年龄阈值”通过参数MaxTenuringThreshold设定，默认值为15
      * 8:1:1，会在S1多待一段时间而不是立马分到老年代
        * 对象最好不要进入老年代——Major GC，比Minor GC慢10倍
        * 对象最好是在新生代被回收掉，对象生命周期不一样——分代
      * TLAB（Thread-local allocation buffer）
        * JVM会为每个线程在Eden Space中开辟一小块线程私有的区域TLAB
          * 在对象分配的时候不用锁住整个堆，而只需要在自己的缓冲区分配即可
        * 在Java程序中很多对象都是小对象且用过即丢，它们不存在线程共享也适合被快速GC，适合优先分配在TLAB上，并且线程私有，没有锁开销，分配多个小对象比分配一个大对象效率高
    * Survivor from：S0
    * Survivor to：S1
  * 老年代
    * 进入条件（该区域中对象存活率高）
      * 新生代垃圾回收一次，存活对象的年龄就加1，当年龄大于预设值就进入老年代
      * 大对象，-XX:PretenureSizeThreshold 大于这个参数的对象直接在老年代分配，来避免新生代GC以及分配担保机制和Eden与Survivor之间的复制
      * 如果Survivor空间无法容纳新生代中Minor GC之后还存活的对象
      * 如果Survivor中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于等于该年龄的对象进入老年代
    * 老年代的垃圾回收（又称Major GC）通常使用“标记-清理”或“标记-整理”算法
    * 整堆包括新生代和老年代的垃圾回收称为Full GC
      * HotSpot VM里，除了CMS之外，其它能收集老年代的GC都会同时收集整个GC堆，包括新生代

- 内存分配策略

  - 对象优先在 Eden 分配
  - 大对象直接进入老年代
  - 长期存活的对象将进入老年代

## GC回收机制

- 当Java程序性能达不到既定目标，且其他优化手段都已经穷尽时，通常需要调整垃圾回收器来进一步提高性能，称为GC优化

- 当代主流虚拟机（Hotspot VM）的垃圾回收都采用“分代回收”的算法。

  - “分代回收”是基于：对象的生命周期不同，所以针对不同生命周期的对象可以采取不同的回收方式，以便提高回收效率

- Java 中的垃圾回收一般是在 Java 堆中进行，因为堆中几乎存放了 Java 中所有的对象实例

  - 引用类型
    - 不同场景使用不同的引用类型，使得对象能够合理的被JVM的垃圾回收机制回收，避免OOM
    - 强引用：如“Object obj = new Object（）”，只要强引用还存在，垃圾收集器就永远不会回收掉被引用的对象。GC Root不可达时被回收
    - 软引用：内存不足时被GC回收
    - 弱引用：只要GC就回收
    - 虚引用：无法通过虚引用来取得一个对象实例，唯一目的是希望该对象被回收时能收到一个系统通知

- 回收对象

  - 不可达对象：
  - 当一个对象到GC Roots没有任何引用链相连时则此对象是不可用的
    - 以一系列的GC Roots的对象作为起点向下搜索走过的路径称为引用链
    - GC Roots包括：虚拟机栈中引用的对象、方法区中类静态属性引用的对象、方法区中常量引用的对象、本地方法栈中JNI（Native方法）引用的对象。

- 彻底死亡条件：

  - 条件1：通过GC Roots作为起点的向下搜索形成引用链，没有搜到该对象，这是第一次标记。
  - 条件2：在finalize方法中没有逃脱回收（将自身被其他对象引用），这是第一次标记的清理。

- 如何回收

  - 新生代
  - Minor GC，当新生代Eden区空间不足以继续分配对象，发起Minor GC
    - 因为每次GC都有大批对象死去，所以采用复制成本低且无碎片的复制算法
    - 复制算法：
      - 将可用内存按容量划分为Eden、from survivor、to survivor
      - Minor GC后将存活的对象复制到另一个survivor，然后将原来已使用的内存一次清理掉，这样没有内存碎片
  - 老年代
    - Major GC
    - 因为存活率高、没有分配担保空间，如果执行较多的复制操作，效率将会变低，所以使用“标记-清理”或者“标记-整理”算法
    - 标记-清除
      - 首先标记出所有需要回收的对象，标记完成后统一回收被标记的对象
      - 会产生大量碎片，导致无法分配大对象从而导致频繁GC。
      - 它的标记过程其实就是前面的根搜索算法中判定垃圾对象的标记过程
    - 标记-整理
      - 首先标记出所有需要回收的对象，让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存

- Full GC条件

  - Full GC：新生代+老年代，垃圾回收器最终目的是减少Full GC

  1. 调用System.gc时，系统建议执行Full GC，但是不必然执行
  2. 老年代空间不足（通过Minor GC后进入老年代的大小大于老年代的可用内存）
  3. 方法区空间不足

## 垃圾收集器

- 只负责回收堆内存中的对象
  - 程序无法精确控制垃圾回收的运行，其会在合适的时候进⾏
  - 回收任何对象之前，总会先调用它的finalize()方法(不一定会被执行)=>可导致该对象重新复活
  - 可达状态 可恢复状态 不可达状态
  - `System.gc()` 、`Runtime.getRuntime().gc()`
- 串行收集器
  - 串行收集器Serial是最古老的收集器，只使用一个线程去回收，可能会产生较长的停顿
  - 新生代使用Serial收集器`复制`算法、老年代使用Serial Old`标记-整理`算法
  - 参数：`-XX:+UseSerialGC`，默认开启`-XX:+UseSerialOldGC`
- 并行收集器
  - 并行收集器Parallel关注可控的吞吐量，使用多线程收集，能精确地控制吞吐量与最大停顿时间是该收集器最大的特点，也是1.8的Server模式的默认收集器。ParNew垃圾收集器是Serial收集器的多线程版本。
  - 新生代`复制`算法、老年代`标记-整理`算法
  - 参数：`-XX:+UseParallelGC`，默认开启`-XX:+UseParallelOldGC`
- 并发收集器
  - 并发收集器CMS是以最短停顿时间为目标。G1关注能在大内存的前提下精确控制停顿时间且垃圾回收效率高。
  - CMS针对老年代，有初始标记、并发标记、重新标记、并发清除四个过程，标记阶段会Stop The World，使用`标记-清除`算法，所以会产生内存碎片。
  - 参数：`-XX:+UseConcMarkSweepGC`，默认开启`-XX:+UseParNewGC`
  - G1将堆划分为多个大小固定的独立区域，根据每次允许的收集时间优先回收垃圾最多的区域，使用`标记-整理`算法，是1.9的Server模式的默认收集器
  - 参数：`-XX:+UseG1GC`
- 如何选择垃圾收集器
  1. 需要停顿时间能超过1秒且想要一个可控的吞吐量时，使用并行收集器
  2. 如果停顿时间重要且不超过1秒，使用并发收集器
  3. 如果内存小于100M，使用串行或者JVM自己选
  4. 如果是单核，且没有系统停顿要求，使用串行或者JVM自己选
- Stop The World，STW
  - 是在执行垃圾收集算法时，Java应用程序的其他所有线程都被挂起，Java中一种全局暂停现象
  - STW总会发生，不管是新生代还是老年代，只能尽量去减少STW的时间
    - 比如CMS在初始标记和重复标记阶段会停顿，G1在初始标记阶段也会停顿
  - 那么为什么一定要STW？
    - 因为在定位堆中的对象时JVM会记录下对所有对象的引用
    - 如果在定位对象过程中，有新的对象被分配或者刚记录下的对象突然变得无法访问，就会导致一些问题
      - 比如部分对象无法被回收，更严重的是如果GC期间分配的一个GC Root对象引用了准备被回收的对象，那么该对象就会被错误地回收。

# 堆中对象

## 创建

- 普通Java对象，不包括数组和Class对象的创建

- 虚拟机遇到一条new指令时：

  1. 检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析和初始化过，如果没有，必须先执行相应的类加载过程

  2. 类加载检查通过后，虚拟机为新生对象分配内存，对象所需内存大小在类加载完成后便可完全确定

     分配方式：

     - 堆内存是绝对规整——指针碰撞
       - 用过的在一边，没有过的在另一边，中间的指针向空闲空间挪动一段与对象大小相等的距离
     - 堆内存不规整——空闲列表
       - 已用和空闲内存空间相互交错，虚拟机必须维护一个列表来记录哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上记录

     选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定

     并发线程安全问题：

     - 对分配内存空间的动作进行同步处理
     - 把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在 Java堆中预先分配一小块内存，称为本地线程分配缓冲TLAB，哪个线程要分配内存，就在哪个线程的TLAB上分配，只有TLAB用完并分配新的TLAB时，才需要同步锁定

  3. 内存分配完成后，JVM需将分配到内存空间都初始化为零值（不包括对象头），保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用

  4. JVM对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。这些信息存放在对象的对象头中

  5. 执行`<init>`方法，把对象按照程序员的意愿进行初始化

## 对象内存布局

HotSpot虚拟机中，对象在内存中存储的布局可以分为3块区域：

- 对象头

  - 第一部分用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等
  - 另一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。如果对象是一个Java数组，那在对象头中还必须有一块用于记录数组长度的数据，因为虚拟机可以通过普通Java对象的元数据信息确定Java对象的大小，但是从数组的元数据中却无法确定数组的大小

- 实例数据

  是对象真正存储的有效信息，也是程序代码中所定义的各种类型的字段内容

  无论是从父类继承下来，还是在子类中定义的，都需要记录起来

- 对齐填充

  不是必然存在的，仅仅起者占位符的作用

  由于HotSpot VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍（对象的大小必须是8字节的整数倍），而对象头部分正好是8字节的倍数（1倍或者2倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全

## 访问定位

- Java 程序需要通过栈上的reference数据来操作堆上的具体对象

- 对象访问方式：

  1. 使用句柄

     Java堆中将会划分出一块内存来作为句柄池，reference（栈的本地变量表中）中存储的就是对象的句柄地址，而句柄中包含了对象实例数据（堆）与类型数据（方法区）各自的具体地址信息

     好处：reference中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而reference本身不需要修改

  2. 直接指针

     reference中存储的直接就是对象的地址

     好处：速度更快，节省了一次指针定位的时间开销





