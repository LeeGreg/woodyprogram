# MS

- 说一下java堆的空间结构，常用的jvm内存分析命令及工具
  - JVM调优的常见命令工具包括：
    1. ==jps用来显示本地的java进程==，可以查看本地运行着几个java程序，并显示他们的进程号
    2. jstat可以实时显示本地或远程JVM进程中类装载、内存、垃圾收集、JIT编译等数据`jstat [option] LVMID [interval] [count]`，可以用来==监视VM内存内的各种堆和非堆的大小及其内存使用量==
       - jstat查看gc实时执行情况
         - ` jstat -gc 12538 5000`
         - 每5 秒一次显示进程号为 12538的 java进成的 GC情况
    3. ==jinfo==用于查询当前运行着的JVM属性和参数的值`jinfo [option] <pid>`
    4. ==jmap==用于显示当前Java堆和永久代的详细信息`jmap [option] <pid>`，打印出某个java进程（使用pid）内存内的所有'对象'的情况（如：产生那些对象，及其数量）
       - jmap查看各个代的内存使用
         - `jmap -heap pid `
         - `jmap -heap 2083`
    5. jhat用于分析使用jmap生成的dump文件，是JDK自带的工具
    6. ==jstack用于生成当前JVM的所有线程快照==，线程快照是虚拟机每一条线程正在执行的方法,目的是定位线程出现长时间停顿的原因，例如死锁，死循环等`jstack [-l] <pid> (连接运行中的进程)`
  - java内存溢出问题你们是怎么排查的
    - dump
      - `kill -3 <pid>`
        - **pid：** Java 应用的进程 id ,也就是需要抓取 dump 文件的应用进程 id 
      - 当使用 `kill -3` 生成 dump 文件时，dump 文件会被输出到标准错误流。假如你的应用运行在 tomcat 上，dump 内容将被发送到`<TOMCAT_HOME>/logs/catalina.out`文件里
    - 然后用 Profiler 工具
  - 图形化工具：
    - jconsole：一个java GUI监视工具，可以以图表化的形式显示各种数据。并可通过远程连接监视远程的服务器VM
    - jvisualvm
  - JVM常见的调优参数包括：
    1. ==-Xmx==：指定java程序的最大堆内存, 使用java -Xmx5000M -version判断当前系统能分配的最大堆内存
    2. ==-Xms==：指定最小堆内存, 通常设置成跟最大堆内存一样，减少GC
    3. ==-Xmn==：设置年轻代大小。整个堆大小=年轻代大小 + 年老代大小。所以增大年轻代后，将会减小年老代大小。此值对系统性能影响较大，Sun官方推荐配置为整个堆的3/8
    4. -Xss：指定线程的最大栈空间, 此参数决定了java函数调用的深度, 值越大调用深度越深, 若值太小则容易出栈溢出错误(StackOverflowError)
    5. -XX:PermSize：指定方法区(永久区)的初始值,默认是物理内存的1/64， 在Java8永久区移除, 代之的是元数据区， 由-XX:MetaspaceSize指定
    6. -XX:MaxPermSize：指定方法区的最大值, 默认是物理内存的1/4， 在java8中由-XX:MaxMetaspaceSize指定元数据区的大小
    7. -XX:NewRatio=n：年老代与年轻代的比值，-XX:NewRatio=2, 表示年老代与年轻代的比值为2:1
    8. -XX:SurvivorRatio=n：Eden区与Survivor区的大小比值，-XX:SurvivorRatio=8表示Eden区与Survivor区的大小比值是8:1:1，因为Survivor区有两个(from, to)
- ==Serial 与 Parallel GC之间的不同之处？==
  - Serial 与 Parallel 在GC执行的时候都会引起 stop-the-world。
  - 它们之间主要不同 serial 收集器是默认的复制收集器，执行 GC 的时候只有一个线程，而 parallel 收集器使用多个 GC 线程来执行
- Java 中 WeakReference 与 SoftReference的区别？
  - 虽然 WeakReference 与 SoftReference 都有利于提高 GC 和 内存的效率
  - 但是 WeakReference ，没有任何引用时，就会被 GC 回收，而软引用虽然不能阻止被回收，但是可以延迟到 JVM 内存不足的时候
- WeakHashMap 是怎么工作的
  - WeakHashMap 的工作与正常的 HashMap 类似，但是使用弱引用作为 key，意思就是当 key 对象没有任何引用时，key/value 将会被回收
- JVM 选项 -XX:+UseCompressedOops 有什么作用？为什么要使用？
  - 当你将你的应用从 32 位的 JVM 迁移到 64 位的 JVM 时，由于对象的指针从 32 位增加到了 64 位，因此堆内存会突然增加，差不多要翻倍。这也会对 CPU 缓存（容量比内存小很多）的数据产生不利的影响。因为，迁移到 64 位的 JVM 主要动机在于可以指定最大堆大小，通过压缩 OOP 可以节省一定的内存。通过 -XX:+UseCompressedOops 选项，JVM 会使用 32 位的 OOP，而不是 64 位的 OOP
- 怎样通过 Java 程序来判断 JVM 是 32 位 还是 64 位？
  - 可以检查某些系统属性如 sun.arch.data.model 或 os.arch 来获取该信息
    - `System.getProperty("sun.arch.data.model")`
  - java -d32、java-d64
- 32 位 JVM 和 64 位 JVM 的最大堆内存分别是多数？
  - 理论上说上 32 位的 JVM 堆内存可以到达 2^32，即 4GB，但实际上会比这个小很多
  - 64 位 JVM允许指定最大的堆内存，理论上可以达到 2^64
- ==解释 Java 堆空间及 GC==
  - 当通过 Java 命令启动 Java 进程的时候，会为它分配内存。内存的一部分用于创建堆空间，当程序中创建对象的时候，就从堆空间中分配内存。
  - GC 是 JVM 内部的一个进程，回收==无效==对象的内存用于将来的分配
- 能保证 GC 执行吗
  - 不能，虽然你可以调用 System.gc() 或者 Runtime.gc()，但是没有办法保证 GC 的执行
- 怎么获取 Java 程序使用的内存？堆使用的百分比
  - 可以通过 java.lang.Runtime 类中与内存相关方法来获取剩余的内存，总内存及最大堆内存。通过这些方法你也可以获取到堆使用的百分比及堆内存的剩余空间
  - Runtime.maxMemory() ：java虚拟机（这个进程）能构从操作系统那里挖到的最大的内存，以字节为单位，如果在运行java程序的时 候，没有添加-Xmx参数，那么就是64兆
  - Runtime.totalMemory() ：java虚拟机现在已经从操作系统那里挖过来的内存大小
  - Runtime.freeMemory() ：挖过来而又没有用上的内存
    - ==`Runtime.getRuntime().freeMemory()`==
- ==Java 中堆和栈有什么区别==
  - JVM 中堆和栈属于不同的内存区域，使用目的也不同。
  - 栈常用于保存方法帧和局部变量，而对象总是在堆上分配。
  - 栈通常都比堆小，也不会在多个线程之间共享，而堆被整个 JVM 的所有线程共享

# JVM原理

- JVM本身是介于==JAVA编译器==和==操作系统==之间的程序，这个程序提供了一个==无视==操作系统和==硬件平台==的运行环境
- 将字节码转换成机器能够识别的机器码
- 软件层面机器码翻译（.class -> 机器能够识别的字节码）
- 内存管理

## Java内存区域的分配

![image-20190301164735383](/Users/dingyuanjie/Desktop/myself/image-20190301164735383.png)

- 按线程是否共享分为以下区域

  - 所有线程==共享==的数据区：
    1. 方法区（JVM规范中的一部分，不是实际的实现）:==存储每一个类的结构信息==（运行时常量池、方法数据、==静态变量、构造函数和普通方法的字节码==、JIT编译后的代码)，没有要求使用垃圾回收因为回收效率太低。（运行时常量池：存放编译器生成的各种字面量和符号引用，在类加载后放到运行时常量池中）
    2. 堆区: 最大的一块区域，==是大部分类实例、对象、数组分配内存的区域==，没有限制只能将对象分配在堆，所以出现逃逸分析的技术
  - 每个线程都会有一块==私有==的数据区：
    1. 虚拟机栈: 虚拟机栈与线程同时创建，每个方法在执行时在其中创建一个栈帧，用于存储==局部变量表（基本数据类型和对象引用）==、操作数栈、、方法返回地址。正常调用完成后恢复调用者的局部变量表、操作数栈、递增程序计数器来跳过刚才执行的指令，或抛出异常不将返回值返回给调用者
    2. 本地方法栈: 功能与虚拟机栈相同，==为native方法服务==
    3. 程序计数器：当前线程所执行的字节码的行号指示器。唯一一个没有内存溢出的区域。在虚拟机的概念模型里，字节码解释器工作时就是==通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器完成==。为了线程切换后能恢复到正确地执行位置，每条线程都需要有一个独立的程序计数器

- 以HotSpot虚拟机实现为例，Java8中内存区域如下：

  ![image-20190301165233107](/Users/dingyuanjie/Desktop/myself/image-20190301165233107.png)

- 与规范中的区别：

  1. 直接内存：非Java标准，是==JVM以外的本地内存==，在Java4出现的NIO中，为了防止Java堆和Native堆之间往复的数据复制带来的性能损耗，此后NIO可以使用Native的方式直接在Native堆分配内存。JDK中有一种基于通道（Channel）和缓冲区（Buffer）的内存分配方式，将由C语言实现的native函数库分配在直接内存中，用存储在JVM堆中的DirectByteBuffer来引用。
  2. 元数据区（==方法区的实现==）：Java7以及之前是使用的==永久代==来实现方法区，大小是在启动时固定的。Java8中用==元空间==替代了永久代，元空间并不在虚拟机中，而是使用本地内存，并且大小可以是自动增长的，这样减少了OOM的可能性。元空间存储JIT即时编译后的native代码，可能还存在短指针数据区CCS
  3. 常量池: Java7之后运行时常量池从方法区移到堆区，为Java8移除永久带的做好准备

## Java对象不都是分配在堆上

- 逃逸分析

  - 逃逸是指在==某个方法之内创建的对象除了在方法体之内被引用之外，还在方法体之外被其它变量引用到；这样带来的后果是在该方法执行完毕之后，该方法中创建的对象将无法被GC回收==。

  - 由于其被其它变量引用，由于无法回收，即称为逃逸。

    ```java
    public static StringBuffer craeteStringBuffer(String s1, String s2) {
            StringBuffer sb = new StringBuffer();
            sb.append(s1);
            sb.append(s2);
            return sb;   //逃逸
        	//返回类型 String ，然后 return sb.toString() //未逃逸
        }
    ```

  - 逃逸分析技术可以分析出某个对象是否永远只在某个方法、线程的范围内，并没有“逃逸”出这个范围，逃逸分析的一个结果就是对于某些未逃逸对象可以直接在栈上分配提高对象分配回收效率，对象占用的空间会随栈帧的出栈而销毁

## 类加载机制

* 虚拟机的类加载机制：==虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型==
* 类型的加载、连接和初始化过程都是在程序运行期间完成的——提供高度的灵活性，天生可以动态扩展的语言特性就是依赖运行期动态加载和动态连接

- 加载过程
  1. ==加载==（获取来自任意来源的字节流并转换成运行时数据结构，生成Class对象）
  2. ==验证==（验证字节流信息符合当前虚拟机的要求，防止被篡改过的字节码危害JVM安全）
  3. ==准备==（为类变量分配内存并设置初始值）
  4. ==解析==（将常量池的符号引用替换为直接引用，符号引用是用一组符号来描述所引用的目标，直接引用是指向目标的指针）
     * 解析阶段在某些情况下可以在初始化阶段之后再开始——为了支持Java语言的运行时绑定
  5. ==初始化==（类变量赋值、静态语句块、执行类构造器）
- ClassLoader
  - 用来动态加载class⽂件到内存当中
    - 程序在启动的时候，并不会一次性加载程序所要用的所有class文件，而是根据程序的需要，通过Java的类加载机制(ClassLoader)来动态加载某个class文件到内存当中的，从而只有class⽂件被载⼊到了内存之后，才能被其它class所引用
- ClassLoader和Class.forName的区别
  - 都是用来对类（类的全限定名称）进行加载，将.class文件加载到jvm中，但是ClassLoader不会对类进行初始化
    - Class.forName还会对类进行解释，执行其static块（静态代码块和静态成员变量被静态方法赋值），包括加载-连接（验证、准备、解析）-初始化
    - 而ClassLoader只有在newInstance时才执行static块，只是加载，newInstance时才连接、初始化
- ==类加载器==
  - 启动类加载器：用C++语言实现，是虚拟机自身的一部分，它负责将 <JAVA_HOME>/lib路径下的核心类库，无法被Java程序直接引用 
  - 扩展类加载器：用Java语言实现，它负责加载<JAVA_HOME>/lib/ext目录下或者由系统变量-Djava.ext.dir指定位路径中的类库，开发者可以直接使用
  - 系统类加载器：用Java语言实现，它负责加载系统类路径ClassPath指定路径下的类库，开发者可以直接使用
- JVM虚拟机认为，两个类相等的条件是：来源于同一个Class文件且被同一个虚拟机加载
- 自定义类加载器
  - 如果不想打破双亲委派模型，那么只需要重写findClass方法即可
  - 如果想打破双亲委派模型，那么就重写整个loadClass方法
- 双亲委派
  - 定义：如果最顶层的父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载
  - 优点：Java类随着它的类加载器一起具备了一种带有==优先级的层次关系==，通过这种层级关可以==避免类的重复加载==，当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。其次==防止恶意覆盖Java核心API==。
- 三次大型破坏双亲委派模式的事件：
  1. 在双亲委派模式出来之前，用户继承ClassLoader就是为了==重写loadClass方法==（破坏双亲委派模式），但双亲委派模式需要这个方法，所以1.2之后添加了findClass供以后的用户重写。
  2. 如果==基础类要调回用户的代码==，如JNDI/JDBC需要调用ClassPath下的自己的代码来进行资源管理，Java团队添加了一个线程上下文加载器，如果该加载器没有被设置过，那么就默认是应用程序类加载器
  3. 为了实现==代码热替换==，OSGi是为了实现自己的类加载逻辑，用平级查找的逻辑替换掉了向下传递的逻辑。但其实可以不破坏双亲委派逻辑而是自定义类加载器来达到代码热替换
- 立即初始化类的情况
  - 创建类的实例时，如new，但是通过数组定义来引用类，不会触发此类的初始化`SuperClass[] sca = new SuperClass[10]`
  - 初始化一个类时，如果其父类还没初始化，则需先触发其父类初始化（接口有所不同，只有在真正使用到父接口的时候才会初始化）
  - 使用反射⽅式来强制创建某个类或接口对应的java.lang.Class对象
  - 调用某个类的静态⽅法
  - 当虚拟机启动时会初始化一个要执行的主类（包括main方法的那个类）
- 通过子类引用父类的静态字段，不会导致子类的初始化，只会触发父类的初始化（对于静态字段，只有直接定义这个字段的类才会被初始化）

## 内存分配（堆上的内存分配）

![image-20190301165618822](/Users/dingyuanjie/Desktop/myself/image-20190301165618822.png)

- ==新生代==

  - 进入条件
    - 大多数对象在新生代中被创建，其中很多对象的生命周期很短
    - 每次新生代的垃圾回收（又称Minor GC）后只有少量对象存活，所以选用==复制算法==，只需要少量的复制成本就可以完成回收
    - 新生代内又分三个区：==一个Eden区，两个Survivor区==（一般而言），==大部分对象在Eden区中生成。当Eden区满时，还存活的对象将被复制到两个Survivor区中的一个。当这个Survivor区满时，此区的存活且不满足“晋升”条件的对象将被复制到另外一个Survivor区==
    - 对象每经历一次Minor GC，年龄加1，达到“晋升年龄阈值”后，被放到老年代，这个过程也称为“晋升”。在Serial和ParNew GC两种回收器中，“晋升年龄阈值”通过参数MaxTenuringThreshold设定，默认值为15
    - 8:1:1原因
      - 当eden快要满了时会进行第一次Minor GC回收（只回收eden区），回收不了的会分配到s0区，当eden快满的时候就行第二次Minor GC回收（回收eden和S0区），回收不了的分配到S1，当S1满了就分配到老年代
      - 8:1:1，会在S1多待一段时间而不是立马分到老年代（对象最好不要进入老年代——Major GC，比Minor GC慢10倍，对象最好是在新生代被回收掉），对象生命周期不一样——分代
    - ==TLAB==
      - JVM在内存==新生代Eden Space中开辟了一小块线程私有的区域==TLAB（Thread-local allocation buffer）。在Java程序中很多对象都是==小对象且用过即丢==，它们不存在线程共享也适合被快速GC，所以对于小对象通常JVM会优先分配在TLAB上，并且TLAB上的分配由于是线程私有所以没有锁开销。因此在实践中==分配多个小对象的效率通常比分配一个大对象的效率要高==。
      - 也就是说，==Java中每个线程都会有自己的缓冲区称作TLAB，在对象分配的时候不用锁住整个堆，而只需要在自己的缓冲区分配即可==

- ==老年代==

  - 进入条件

    - 在==新生代中经历了N次垃圾回收后仍然存活的对象==，就会被放到年老代，该区域中对象存活率高
    - 老年代的垃圾回收（又称Major GC）通常使用“标记-清理”或“标记-整理”算法。
    - 整堆包括新生代和老年代的垃圾回收称为Full GC（HotSpot VM里，除了CMS之外，其它能收集老年代的GC都会同时收集整个GC堆，包括新生代）。

    1. ==大对象==，-XX:PretenureSizeThreshold ==大于这个参数的对象==直接在老年代分配，来避免新生代GC以及分配担保机制和Eden与Survivor之间的复制
    2. 经过第一次Minor GC仍然存在，能被Survivor容纳，就会被移动到Survivor中，此时年龄为1，当年龄大于预设值就进入老年代
    3. 如果Survivor中==相同年龄所有对象大小的总和大于Survivor空间的一半==，年龄大于等于该年龄的对象进入老年代
    4. 如果Survivor空间==无法容纳新生代中Minor GC之后还存活的对象==

- 永久代（java7）

  - 主要存放元数据，例如Class、Method的元信息，与垃圾回收要回收的Java对象关系不大。相对于新生代和年老代来说，该区域的划分对垃圾回收影响比较小

- Meta Space（java1.8）

- 内存分配策略

  - 对象优先在 Eden 分配
  - 大对象直接进入老年代
  - 长期存活的对象将进入老年代

## GC回收机制

- 当Java程序性能达不到既定目标，且其他优化手段都已经穷尽时，通常需要调整垃圾回收器来进一步提高性能，称为GC优化

- 当代主流虚拟机（Hotspot VM）的垃圾回收都采用“==分代回收==”的算法。“分代回收”是基于这样一个事实：==对象的生命周期不同，所以针对不同生命周期的对象可以采取不同的回收方式，以便提高回收效率==

- Java 中的垃圾回收一般是在 Java 堆中进行，因为堆中几乎存放了 Java 中所有的对象实例

  - 引用类型
    - 不同场景使用不同的引用类型，使得对象能够合理的被JVM的垃圾回收机制回收，避免OOM
    - 强引用：如“Object obj = new Object（）”，只要强引用还存在，垃圾收集器就永远不会回收掉被引用的对象，==GC Root不可达时被回收==
    - 软引用：它用来描述一些可能还有用，但并非必须的对象。在系统内存不够用时，这类引用关联的对象将被垃圾收集器回收，==内存不足时被GC回收==
    - 弱引用：它也是用来描述非需对象的，但它的强度比软引用更弱些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象，==只要GC就回收==
    - 虚引用：最弱的一种引用关系，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的是希望能==在这个对象被收集器回收时收到一个系统通知==，被引用时会被通知到

- 回收对象

  - 不可达对象：通过一系列的GC Roots的对象作为起点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，==当一个对象到GC Roots没有任何引用链相连时则此对象是不可用的==。
  - GC Roots包括：虚拟机栈中引用的对象、方法区中类静态属性引用的对象、方法区中常量引用的对象、本地方法栈中JNI（Native方法）引用的对象。

- 彻底死亡条件：

  - 条件1：通过GC Roots作为起点的向下搜索形成引用链，没有搜到该对象，这是第一次标记。
  - 条件2：在finalize方法中没有逃脱回收（将自身被其他对象引用），这是第一次标记的清理。

- 如何回收

  - 新生代因为每次GC都有大批对象死去，只需要付出少量存活对象的复制成本且无碎片所以使用“复制算法”。
  - 老年代因为存活率高、没有分配担保空间，如果执行较多的复制操作，效率将会变低，所以使用“标记-清理”或者“标记-整理”算法
  - ==复制算法==：将可用内存按容量划分为Eden、from survivor、to survivor，分配的时候使用Eden和一个survivor，==Minor GC后将存活的对象复制到另一个survivor，然后将原来已使用的内存一次清理掉。这样没有内存碎片==。
    - 将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当一块内存用完了，将其存在另外一块上面，然后再把已使用过的内存空间一次清理掉
  - ==标记-清除==：首先标记出所有需要回收的对象，标记完成后统一回收被标记的对象。会产生大量碎片，导致无法分配大对象从而导致频繁GC。
    - 它的标记过程其实就是前面的根搜索算法中判定垃圾对象的标记过程
  - ==标记-整理==：首先标记出所有需要回收的对象，让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存

- Minor GC条件

  - 当新生代Eden区空间不足以继续分配对象，发起Minor GC。

- Major GC：老年代

- Full GC条件

  - Full GC：新生代+老年代，垃圾回收器最终目的是减少Full GC

  1. 调用System.gc时，系统建议执行Full GC，但是不必然执行
  2. 老年代空间不足（通过Minor GC后进入老年代的大小大于老年代的可用内存）
  3. 方法区空间不足

## 垃圾收集器

- 只负责回收堆内存中的对象
  - ==程序无法精确控制垃圾回收的运行，其会在合适的时候进⾏==
  - 回收任何对象之前，总会先调用它的==finalize()==方法(不一定会被执行)=>可导致该对象重新复活
  - 可达状态 可恢复状态 不可达状态
  - `System.gc()` 、`Runtime.getRuntime().gc()`
- ==串行收集器==
  - 串行收集器Serial是最古老的收集器，只使用==一个线程去回收，可能会产生较长的停顿==
  - 新生代使用Serial收集器`复制`算法、老年代使用Serial Old`标记-整理`算法
  - 参数：`-XX:+UseSerialGC`，默认开启`-XX:+UseSerialOldGC`
- ==并行收集器==
  - 并行收集器Parallel关注**可控的吞吐量**，==使用多线程收集，能精确地控制吞吐量与最大停顿时间==是该收集器最大的特点，也是1.8的Server模式的默认收集器。ParNew垃圾收集器是Serial收集器的多线程版本。
  - 新生代`复制`算法、老年代`标记-整理`算法
  - 参数：`-XX:+UseParallelGC`，默认开启`-XX:+UseParallelOldGC`
- ==并发收集器==
  - 并发收集器==CMS==是以**最短停顿时间**为目标的收集器。==G1==关注能在大内存的前提下精确控制**停顿时间**且垃圾回收效率高。
  - CMS针对老年代，有初始标记、并发标记、重新标记、并发清除四个过程，标记阶段会Stop The World，使用`标记-清除`算法，所以会产生内存碎片。
  - 参数：`-XX:+UseConcMarkSweepGC`，默认开启`-XX:+UseParNewGC`
  - G1将堆划分为多个大小固定的独立区域，根据每次允许的收集时间优先回收垃圾最多的区域，使用`标记-整理`算法，是1.9的Server模式的默认收集器
  - 参数：`-XX:+UseG1GC`
- ==如何选择垃圾收集器==
  1. 需要停顿时间能超过1秒且想要一个可控的吞吐量时，使用并行收集器
  2. 如果停顿时间重要且不超过1秒，使用并发收集器
  3. 如果内存小于100M，使用串行或者JVM自己选
  4. 如果是单核，且没有系统停顿要求，使用串行或者JVM自己选
- Stop The World
  - Java中Stop-The-World机制简称STW，==是在执行垃圾收集算法时，Java应用程序的其他所有线程都被挂起==。Java中一种全局暂停现象，全局停顿，所有Java代码停止，native代码可以执行，但不能与JVM交互
  - STW总会发生，不管是新生代还是老年代，比如CMS在初始标记和重复标记阶段会停顿，G1在初始标记阶段也会停顿，所以并不是选择了一款停顿时间低的垃圾收集器就可以避免STW的，我们==只能尽量去减少STW的时间==。
  - 那么为什么一定要STW？因为==在定位堆中的对象时JVM会记录下对所有对象的引用，如果在定位对象过程中，有新的对象被分配或者刚记录下的对象突然变得无法访问，就会导致一些问题==，比如部分对象无法被回收，更严重的是如果GC期间分配的一个GC Root对象引用了准备被回收的对象，那么该对象就会被错误地回收。

# 堆中对象

## 创建

- 普通Java对象，不包括数组和Class对象的创建

- 虚拟机遇到一条new指令时：

  1. 检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析和初始化过，如果没有，必须先执行相应的类加载过程

  2. 类加载检查通过后，虚拟机为新生对象分配内存，对象所需内存大小在类加载完成后便可完全确定

     分配方式：

     - 堆内存是绝对规整——指针碰撞
       - 用过的在一边，没有过的在另一边，中间的指针向空闲空间挪动一段与对象大小相等的距离
     - 堆内存不规整——空闲列表
       - 已用和空闲内存空间相互交错，虚拟机必须维护一个列表来记录哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上记录

     选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定

     并发线程安全问题：

     - 对分配内存空间的动作进行同步处理
     - 把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在 Java堆中预先分配一小块内存，称为本地线程分配缓冲TLAB，哪个线程要分配内存，就在哪个线程的TLAB上分配，只有TLAB用完并分配新的TLAB时，才需要同步锁定

  3. 内存分配完成后，JVM需将分配到内存空间都初始化为零值（不包括对象头），保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用

  4. JVM对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年林等信息。这些信息存放在对象的对象头中

  5. 执行<init>方法，把对象按照程序员的意愿进行初始化

## 对象内存布局

HotSpot虚拟机中，对象在内存中存储的布局可以分为3块区域：

- 对象头

  - 第一部分用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等
  - 另一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。如果对象是一个Java数组，那在对象头中还必须有一块用于记录数组长度的数据，因为虚拟机可以通过普通Java对象的元数据信息确定Java对象的大小，但是从数组的元数据中却无法确定数组的大小

- 实例数据

  是对象真正存储的有效信息，也是程序代码中所定义的各种类型的字段内容

  无论是从父类继承下来，还是在子类中定义的，都需要记录起来

- 对齐填充

  不是必然存在的，仅仅起者占位符的作用

  由于HotSpot VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍（对象的大小必须是8字节的整数倍），而对象头部分正好是8字节的倍数（1倍或者2倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全

## 访问定位

- Java 程序需要通过栈上的reference数据来操作堆上的具体对象

- 对象访问方式：

  1. 使用句柄

     Java堆中将会划分出一块内存来作为句柄池，reference（栈的本地变量表中）中存储的就是对象的句柄地址，而句柄中包含了对象实例数据（堆）与类型数据（方法区）各自的具体地址信息

     好处：reference中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而reference本身不需要修改

  2. 直接指针

     reference中存储的直接就是对象的地址

     好处：速度更快，节省了一次指针定位的时间开销





