# TCP/IP

* `Transmission Control Protocol`，即 传输控制协议

* TCP是一种面向连接的、可靠的、基于字节流、全双工通信的【传输层】通信协议

  * 基于`TCP`的应用层协议有`HTTP`、`SMTP`、`FTP`、`Telnet` 和 `POP3`
  * 全双工：双方不仅都能发信息，而且能够同时发送
  * 半双工：双方都能发信息，但同一时间则只能一方发信息
  * 单工：一方只能发信息，另一方则只能收信息，通信是单向的

* OSI体系结构（7层）：

  * 物理层-链路层-网络层 -传输层-会话层-表示层-应用层

* TCP/IP体系结构（4层）：

  * 网络接口层-网际层（IP）-传输层（TCP/UDP）-应用层（HTTP）

* 五层体系结构

  * 物理层-链路层-网络层-传输层-应用层

* TCP /IP 通信协议（传输控制协议/互联⽹协议），在通信的两端各建立⼀个Socket，从而在通信的两端之间形成网络虚拟链路用于发送和接收数据

  * IP 协议只保证计算机能发送和接收分组数据，但还不能解决数据分组在传输过程中可能出现的问题 

    * IP地址，用于唯一地标识⽹络中的一个通信实体
    * 可以有多个通信程序同时提供网络服务，端口0~65535
  
* TCP协议提供可靠并且无差错(重发机制，没收到确认回复则重发)的通信服务
  
* Java使用Socket对象代表两端的通信端口，并通过Socket产生IO流来进行网络通信
  
  * ServerSocket创建TCP服务器端
  
    * 接收其他通信实体连接请求，其对象⽤于监听来自客户端的Socket连接，如果没有，则一直处于等待状态
  
    * 服务器端应该为每个Socket单独启动一个线程，每个线程负责与一个客户端进⾏通信
  
        ```java
        ServerSocket ss = new ServerSocket(30000); //没有指定IP则默认本机IP
        while(true) {
        //每当接收到客户端Socket的请求时，服务器端也对应产生⼀个Socket 
            Socket s = ss.accept();
        	...
        }
        //连接建⽴后，通过使用 I/O 流在进行通信，每一个socket都有⼀个输出流和⼀个输⼊流，客户端的输出流连接到服务器端的输入流，而客户端的输入流连接到服务器端的输出流
        //TCP 是⼀个双向的通信协议，因此数据可以通过两个数据流在同一时间发送
      ```
  
  * 客户端可以使用Socket的构造器来连接到指定服务器
  
    * 客户端需要和服务器端保持长时间通信
  
        ```java
        //连接到指定服务器，让服务器端的ServerSocket的accept()向下执行 
        //服务器端和客户端就产生一对相互连接的Socket
        Socket s = new Socket("IP",端口);
        s.setSoTimeout(1000); //设置超时 //程序⽆需区分服务器端、客户端，⽽是通过各自的Socket进行通信 
        getInputStream()
        getOutputStream() //程序从Socket中取出数据，向Socket中输出数据
      ```
  
  * URI：统一资源标志符，不能⽤于定位任何资源，唯一作⽤就是解析
  
  * URL：统一资源定位器，指向互联网“资源”的指针，URI的特例
  
      ```java
      URL url = new URL(path); 
      openConnection()//代表了与URL所引用的远程对象的连接
      openStream() //打开与此URL的连接，并返回⼀个用于读取该URL资源的InputStream
      ```

## 三次握手

tcp，三次传输，以确保任何一次失败的连接都不会长时间占用资源

1. 建立连接时，客户端向服务端发送消息，等待服务器确认，客户端进入同步已发送状态
2. 服务端接收并确认消息，若同意建立连接，则向客户端发送连接确认消息，服务器进入同步已接收状态
3. 客户端收到服务端的消息，向服务端发送确认收到消息，该消息发送完毕后，TCP连接成功，完成三次握手

## 四次挥手

1. 客户端向服务端发送连接释放消息
2. 服务端收到客户端发送释放连接消息后，向客户端发送连接释放确认消息
3. 若服务端已无要向客户端发送数据，则发出释放连接消息
4. 客户端接收到连接释放消息后，则向服务端发送连接释放确认消息

* 等待服务端的数据都发送完

## 滑动窗口机制

* 无差错传输
* 是传输层进行流控的一种措施，接收方通过通告发送方自己的窗口大小，来控制发送方的发送速度，从而达到防止发送方发送速度过快而导致自己被淹没的目的
* ACK包含两个非常重要的信息：
  * 一是期望接收到的下一字节的序号n，该n代表接收方已经接收到了前n-1字节数据。
  * 二是当前的窗口大小m
  * 如此发送方在接收到ACK包含的这两个数据后就可以计算出还可以发送多少字节的数据给对方，这就是滑动窗口控制流量的基本原理
* 发送端：
  * 每收到一个确认帧，发送窗口就向前滑动一个帧的距离
  * 当窗口内的帧全部是已发送但未收到确认的，发送方就会停止发送，直到收到接收方发送的确认帧使窗口移动，窗口内有可以发送的帧，之后才开始继续发送
* 接收端：
  * 当收到数据帧后，将窗口向前移动一个位置，并发回确认帧，若收到的数据帧落在接收窗口之外，则一律丢弃

## 和UDP的区别

* UDP协议：面向非连接（直接发送）、不可靠、一次只传送少量数据的用户数据报协议
  * 应用在实时性很强的应用场景，⽐如网络游戏、视频会议等，快速更具独特性
* TCP协议：面向连接、可靠、有序的字节流传输，传输⼤小无限制，但是差错控制开销⼤。对应的协议（FTP/SMTP/HTTP）
* UDP协议：面向非连接、不可靠、无序的数据报文段（每一个都是单独的传输单元）传输，传输⼤小限制在64kb以下，差错控制开销小。对应的协议（DNS）

# Socket

- socket即套接字，本质是一个封装了 TCP / IP协议族的编程接口(API)，可做网络通信开发，是对TCP/IP的封装
  - HTTP是轿车，提供了封装或者显示数据的具体形式；Socket是发动机，提供了网络通信的能力
- 一个 `Socket` 实例唯一代表一个主机上的一个应用程序的通信链路
- `Socket`可基于`TCP`或者`UDP`协议，但TCP更加常用
- 服务器
  - 创建一个ServerSocket实例，监听指定端口，阻塞等待客户端的连接请求，完成三次握手，返回服务端Socket实例，然后服务端和客户端可进行通信
- 客户端
  - 创建一个Socket实例，分配本地端口，通过远程地址、端口号连接远程服务端，完成三次握手，Socket实例创建完成
- Socket 与 Http 对比
  - `Socket`属于传输层，因为 `TCP / IP`协议属于传输层，**解决的是数据如何在网络中传输的问题**
  - `HTTP`协议 属于应用层，**解决的是如何包装数据**
  - `Http`：采用 **请求—响应** 方式，即建立网络连接后，当客户端向服务器发送请求后，服务器端才能向客户端返回数据
  - `Socket`： **服务器可主动发送数据** ，即建立网络连接后，服务器可主动发送消息给客户端

* 在浏览器中输入网址会发生什么

  1. 由域名到ip地址，寻址的过程
     * 经过了浏览器缓存、系统缓存、hosts文件、路由器缓存、递归搜索根域名服务器
  2. 建立tcp/ip链接（三次握手的具体过程）
  3. 由浏览器发送一个http请求
  4. 经过路由器的转发，通过服务器的防火墙，该http请求到达了服务器
  5. 服务器处理该http请求，返回一个响应
  6. 浏览器解析响应

  * 注意的是：
    * http协议是基于tcp/ip的应用层协议，进行http传输之前必须进行tcp链接；
    * http是轿车，提供了封装或者显示数据的具体形式；socket是发动机，提供了网络通信的能力；
    * 两个计算机之间的交流无非是两个端口之间的数据通信，具体的数据会以什么样的形式展示是以不同的应用层协议来定义的

# HTTP

* 使得Web服务器与浏览器之间可以通过互联网或者企业内部网来交换数据

* 是基于TCP/IP协议的【应用层】协议。它不涉及数据包传输，主要规定了客户端和服务器之间的通信格式，是互联网信息交互中最常用的协议，用GET/POST/DELETE/PUT来实现RESTFUL
* `HTTP`协议采用 请求 / 响应 的工作方式
* 特点
  1. 简单快速。只需要传【请求方法】与【资源路径】就能确定资源
  2. 灵活，传输【任意类型】的数据
  3. 无连接，一般一次连接只处理一个请求，结束后主动释放连接，但可以使用keep-alive来复用相同的TCP连接发送多个请求
  4. 无状态，客户端向服务器发送HTTP请求之后，服务器会返回数据，但不会记录任何信息。所以Cookie、Session产生了

# HTTPS

- 经由HTTP进行通信，但利用SSL/TLS来加密数据包
- 是一个确保数据在浏览器与服务器之间传输安全的协议
- HTTPS 由两部分组成：HTTP协议+SSL（TLS）协议，也就是在HTTP上又加了一层处理加密信息的模块，传输的数据都是加密后的数据
  - SSL，传输层安全性协议，目的是为互联网通信提供安全及数据完整性保障
    - 客户端向服务器端索要并验证公钥
    - 双方用协商生成的"对话密钥"进行加密通信
- 原理：HTTPS在传输数据之前需要客户端与服务器进行一次握手，在握手过程中将确立双方加密传输数据的密码信息

# WebSocket

* 是HTML5新增的协议
* 目的是让客户端和服务端可以互相主动发送消息

1. 支持长连接。WebSocket是一个新协议，可以看成是在HTTP协议上打上一个【支持长连接】的补丁
2. 支持服务器推送。HTTP协议是接收请求然后响应（请求－应答机制限制了TCP/IP全双工通信）。而WebSocket可以让服务器主动推送
3. 基于HTTP。WebSocket是基于HTTP协议，借用HTTP协议完成一部分握手

* 如何建立连接（在Http协议基础之上进行升级握手）
  * 在从标准的HTTP或者HTTPS协议切换到WebSocket时，将会使用一种称为升级握手的机制
    * 客户端发送一个HTTP请求，请求地址以ws://开头，请求头中包含连接升级和升级类型为WebSocket的信息，标识这个连接的信息及WebSocket的版本
    * 服务端接收升级则响应连接升级及升级类型为WebSocket的信息、协议被更改的101响应代码、标识这个连接的信息
    * WebSocket连接建立成功，客户端和服务端都可主动发送消息（二进制或文本）

#  REST/RESTful

* 是一种软件架构风格，不是一个标准，但大部分RESTful Web服务实现会使用HTTP、URI、JSON和XML等各种协议和标准
* 目的是便于不同软件/程序在网络中互相传递信息
* 要点和标准：
  * 资源是由URI来指定
  * 通过操作资源的表现形式（Content-Type）来操作资源，资源的表现形式则是XML、HTML或者JSON
  * 对资源的操作包括创建、获取、修改和删除，这些操作正好对应HTTP协议提供的POST、GET、PUT和DELETE方法
    * PUT和DELETE方法是幂等方法。GET方法是安全方法（不会对服务器端有修改，因此当然也是幂等的）
* 应用场景
  - REST适用于异构系统之间调用，如Java调C等
  - REST适用于网关调用，内部调用用RPC比较好
  - REST的HTTP请求头比较大
  - REST是文本协议，需要序列化/反序列化——成本高
* 优点
  
  * 不需要额外的资源发现机制
  * 可更高效利用缓存来提高响应速度
  * 浏览器即可作为客户端，简化软件需求
  * 相对于其他叠加在HTTP协议之上的机制，REST的软件依赖性更小
  * 通讯本身的无状态性可以让不同的服务器的处理一系列请求中的不同请求，提高服务器的扩展性
  * 在软件技术演进中的长期的兼容性更好
* REST架构风格最重要的架构约束有6个
  * （客户-服务器）C/S架构
    * 通信只能由客户端单方面发起，表现为请求-响应的形式；
    * 客户端与服务器分离模式，任何一个客户端与服务器都是可替换的
  * （无状态）
    * 通信的会话状态应该全部由客户端负责维护
  * （缓存）
    * 响应内容可以在通信链的某处被缓存，以改善网络效率
  * （统一接口）
    * 通信链的组件之间通过统一的接口相互通信，以提高交互的可见性
    * 每个资源都可以通过URI访问到；通过客户端可以修改原资源的状态；客户端根据返回信息可以知道如何处理；处理以超媒体为基础的状态变化
  * （分层系统）
    * 每个组件只能“看到”与其交互的紧邻层，将架构分解为若干等级的层
  * （按需代码）
  * 支持通过下载并执行一些代码，如JavaScript，对客户端的功能进行扩展
  
* 使用REST和使用MVC是类似的，不同的是，提供REST的Controller处理函数最后不调用`render()`去渲染模板，而是把结果直接用JSON序列化返回给客户端



