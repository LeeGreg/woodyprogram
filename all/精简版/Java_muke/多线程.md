![image-20190810112520818](/Users/dingyuanjie/Documents/study/github/woodyprogram/img/image-20190810112520818.png)

![image-20190810112916213](/Users/dingyuanjie/Documents/study/github/woodyprogram/img/image-20190810112916213.png)

![image-20190810113019112](/Users/dingyuanjie/Documents/study/github/woodyprogram/img/image-20190810113019112.png)

![image-20190810113537341](/Users/dingyuanjie/Documents/study/github/woodyprogram/img/image-20190810113537341.png)

![image-20190810113909129](/Users/dingyuanjie/Documents/study/github/woodyprogram/img/image-20190810113909129.png)

* 如何给run()方法传参

  * 构造函数传参、成员变量传参、回调函数传参

* 如何实现处理线程的返回值

  * 主线程等待法

  * 使用Thread类的join()阻塞当前线程以等待子线程处理完毕

  * 通过Callable接口实现：通过FutureTask Or 线程池获取

    ```java
    package com.interview.javabasic.thread;
    
    public class CycleWait implements Runnable{
        private String value;
        public void run() {
            try {
                Thread.currentThread().sleep(5000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            value = "we have data now";
        }
    
        public static void main(String[] args) throws InterruptedException {
            CycleWait cw = new CycleWait();
            Thread t = new Thread(cw);
            t.start();
            // 主线程等待法
    //        while (cw.value == null){
    //            Thread.currentThread().sleep(100);
    //        }
            // join阻塞当前线程以等待子线程处理完毕
            t.join();
            System.out.println("value : " + cw.value);
        }
    }
    
    ```

    ```java
    public class MyCallable implements Callable<String> {
        @Override
        public String call() throws Exception{
            String value="test";
            System.out.println("Ready to work");
            Thread.currentThread().sleep(5000);
            System.out.println("task done");
            return  value;
        }
    }
    
    public class FutureTaskDemo {
        public static void main(String[] args) throws ExecutionException, InterruptedException {
            FutureTask<String> task = new FutureTask<String>(new MyCallable());
            new Thread(task).start();
            if(!task.isDone()){
                System.out.println("task has not finished, please wait!");
            }
            System.out.println("task return: " + task.get());
        }
    }
    
    public class ThreadPoolDemo {
        public static void main(String[] args) {
            ExecutorService newCachedThreadPool = Executors.newCachedThreadPool();
            Future<String> future = newCachedThreadPool.submit(new MyCallable());
            if(!future.isDone()){
                System.out.println("task has not finished, please wait!");
            }
            try {
                System.out.println(future.get());
            } catch (InterruptedException e) {
                e.printStackTrace();
            } catch (ExecutionException e) {
                e.printStackTrace();
            } finally {
                newCachedThreadPool.shutdown();
            }
        }
    }
    ```

    ![image-20190810115334128](/Users/dingyuanjie/Documents/study/github/woodyprogram/img/image-20190810115334128.png)

    ![image-20190810120516514](/Users/dingyuanjie/Documents/study/github/woodyprogram/img/image-20190810120516514.png)

    ![image-20190810120608790](/Users/dingyuanjie/Documents/study/github/woodyprogram/img/image-20190810120608790.png)

    ![image-20190810120703209](/Users/dingyuanjie/Documents/study/github/woodyprogram/img/image-20190810120703209.png)

    ![image-20190810133101859](/Users/dingyuanjie/Documents/study/github/woodyprogram/img/image-20190810133101859.png)

    ![image-20190810133244573](/Users/dingyuanjie/Documents/study/github/woodyprogram/img/image-20190810133244573.png)

    ```java
    public class WaitSleepDemo {
        public static void main(String[] args) {
            final Object lock = new Object();
            new Thread(new Runnable() {
                @Override
                public void run() {
                    System.out.println("thread A is waiting to get lock");
                    synchronized (lock){
                        try {
                            System.out.println("thread A get lock");
                            Thread.sleep(20);
                            System.out.println("thread A do wait method");
                            lock.wait();
                            System.out.println("thread A is done");
                        } catch (InterruptedException e){
                            e.printStackTrace();
                        }
                    }
                }
            }).start();
            try{
                Thread.sleep(10);
            } catch (InterruptedException e){
                e.printStackTrace();
            }
            new Thread(new Runnable() {
                @Override
                public void run() {
                    System.out.println("thread B is waiting to get lock");
                    synchronized (lock){
                        try {
                            System.out.println("thread B get lock");
                            System.out.println("thread B is sleeping 10 ms");
                            Thread.sleep(10);
                            lock.notifyAll();
                            Thread.yield();
                            Thread.sleep(2000);
                            System.out.println("thread B is done");
                        } catch (InterruptedException e){
                            e.printStackTrace();
                        }
                    }
                }
            }).start();
        }
    }
    ```

  ![image-20190810141551582](/Users/dingyuanjie/Documents/study/github/woodyprogram/img/image-20190810141551582.png)

  ![image-20190810141638242](/Users/dingyuanjie/Documents/study/github/woodyprogram/img/image-20190810141638242.png)

  ![image-20190810141801122](/Users/dingyuanjie/Documents/study/github/woodyprogram/img/image-20190810141801122.png)

  ![image-20190810143242894](/Users/dingyuanjie/Documents/study/github/woodyprogram/img/image-20190810143242894.png)

  ```java
  public class NotificationDemo {
      private volatile boolean go = false;
  
      public static void main(String args[]) throws InterruptedException {
          final NotificationDemo test = new NotificationDemo();
  
          Runnable waitTask = new Runnable(){
  
              @Override
              public void run(){
                  try {
                      test.shouldGo();
                  } catch (InterruptedException e) {
                      e.printStackTrace();
                  }
                  System.out.println(Thread.currentThread().getName() + " finished Execution");
              }
          };
  
          Runnable notifyTask = new Runnable(){
  
              @Override
              public void run(){
                  test.go();
                  System.out.println(Thread.currentThread().getName() + " finished Execution");
              }
          };
  
          Thread t1 = new Thread(waitTask, "WT1"); //will wait
          Thread t2 = new Thread(waitTask, "WT2"); //will wait
          Thread t3 = new Thread(waitTask, "WT3"); //will wait
          Thread t4 = new Thread(notifyTask,"NT1"); //will notify
  
          //starting all waiting thread
          t1.start();
          t2.start();
          t3.start();
  
          //pause to ensure all waiting thread started successfully
          Thread.sleep(200);
  
          //starting notifying thread
          t4.start();
  
      }
      /*
       * wait and notify can only be called from synchronized method or bock
       */
      private synchronized void shouldGo() throws InterruptedException {
          while(go != true){
              System.out.println(Thread.currentThread()
                      + " is going to wait on this object");
              wait(); //release lock and reacquires on wakeup
              System.out.println(Thread.currentThread() + " is woken up");
          }
          go = false; //resetting condition
      }
  
      /*
       * both shouldGo() and go() are locked on current object referenced by "this" keyword
       */
      private synchronized void go() {
          while (go == false){
              System.out.println(Thread.currentThread()
                      + " is going to notify all or one thread waiting on this object");
  
              go = true; //making condition true for waiting thread
              //notify(); // only one out of three waiting thread WT1, WT2,WT3 will woke up
              notifyAll(); // all waiting thread  WT1, WT2,WT3 will woke up
          }
  
      }
  }
  ```

  ![image-20190810143044680](/Users/dingyuanjie/Documents/study/github/woodyprogram/img/image-20190810143044680.png)

  ![image-20190810143015163](/Users/dingyuanjie/Documents/study/github/woodyprogram/img/image-20190810143015163.png)

![image-20190810143329915](/Users/dingyuanjie/Documents/study/github/woodyprogram/img/image-20190810143329915.png)

![image-20190810143628946](/Users/dingyuanjie/Documents/study/github/woodyprogram/img/image-20190810143628946.png)

![image-20190810143733089](/Users/dingyuanjie/Documents/study/github/woodyprogram/img/image-20190810143733089.png)

```java
public class InterruptDemo {
    public static void main(String[] args) throws InterruptedException {
        Runnable interruptTask = new Runnable() {
            @Override
            public void run() {
                int i = 0;
                try {
                    //在正常运行任务时，经常检查本线程的中断标志位，如果被设置了中断标志就自行停止线程
                    while (!Thread.currentThread().isInterrupted()) {
                        Thread.sleep(100); // 休眠100ms
                        i++;
                        System.out.println(Thread.currentThread().getName() + " (" + Thread.currentThread().getState() + ") loop " + i);
                    }
                } catch (InterruptedException e) {
                    //在调用阻塞方法时正确处理InterruptedException异常。（例如，catch异常后就结束线程。）
                    System.out.println(Thread.currentThread().getName() + " (" + Thread.currentThread().getState() + ") catch InterruptedException.");
                }
            }
        };
        Thread t1 = new Thread(interruptTask, "t1");
        System.out.println(t1.getName() +" ("+t1.getState()+") is new.");

        t1.start();                      // 启动“线程t1”
        System.out.println(t1.getName() +" ("+t1.getState()+") is started.");

        // 主线程休眠300ms，然后主线程给t1发“中断”指令。
        Thread.sleep(300);
        t1.interrupt();
        System.out.println(t1.getName() +" ("+t1.getState()+") is interrupted.");

        // 主线程休眠300ms，然后查看t1的状态。
        Thread.sleep(300);
        System.out.println(t1.getName() +" ("+t1.getState()+") is interrupted now.");
    }
}
```

![image-20190810144025915](/Users/dingyuanjie/Documents/study/github/woodyprogram/img/image-20190810144025915.png)

![image-20190810144350261](/Users/dingyuanjie/Documents/study/github/woodyprogram/img/image-20190810144350261.png)

![image-20190810144541942](/Users/dingyuanjie/Documents/study/github/woodyprogram/img/image-20190810144541942.png)

![image-20190810145258235](/Users/dingyuanjie/Documents/study/github/woodyprogram/img/image-20190810145258235.png)

![image-20190810145611701](/Users/dingyuanjie/Documents/study/github/woodyprogram/img/image-20190810145611701.png)

```java
public class SyncThread implements Runnable {

    @Override
    public void run() {
        String threadName = Thread.currentThread().getName();
        if (threadName.startsWith("A")) {
            async();
        } else if (threadName.startsWith("B")) {
            syncObjectBlock1();
        } else if (threadName.startsWith("C")) {
            syncObjectMethod1();
        } else if (threadName.startsWith("D")) {
            syncClassBlock1();
        } else if (threadName.startsWith("E")) {
            syncClassMethod1();
        }

    }

    /**
     * 异步方法
     */
    private void async() {
        try {
            System.out.println(Thread.currentThread().getName() + "_Async_Start: " + new SimpleDateFormat("HH:mm:ss").format(new Date()));
            Thread.sleep(1000);
            System.out.println(Thread.currentThread().getName() + "_Async_End: " + new SimpleDateFormat("HH:mm:ss").format(new Date()));
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    /**
     * 方法中有 synchronized(this|object) {} 同步代码块
     */
    private void syncObjectBlock1() {
        System.out.println(Thread.currentThread().getName() + "_SyncObjectBlock1: " + new SimpleDateFormat("HH:mm:ss").format(new Date()));
        synchronized (this) {
            try {
                System.out.println(Thread.currentThread().getName() + "_SyncObjectBlock1_Start: " + new SimpleDateFormat("HH:mm:ss").format(new Date()));
                Thread.sleep(1000);
                System.out.println(Thread.currentThread().getName() + "_SyncObjectBlock1_End: " + new SimpleDateFormat("HH:mm:ss").format(new Date()));
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }

    /**
     * synchronized 修饰非静态方法
     */
    private synchronized void syncObjectMethod1() {
        System.out.println(Thread.currentThread().getName() + "_SyncObjectMethod1: " + new SimpleDateFormat("HH:mm:ss").format(new Date()));
        try {
            System.out.println(Thread.currentThread().getName() + "_SyncObjectMethod1_Start: " + new SimpleDateFormat("HH:mm:ss").format(new Date()));
            Thread.sleep(1000);
            System.out.println(Thread.currentThread().getName() + "_SyncObjectMethod1_End: " + new SimpleDateFormat("HH:mm:ss").format(new Date()));
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    private void syncClassBlock1() {
        System.out.println(Thread.currentThread().getName() + "_SyncClassBlock1: " + new SimpleDateFormat("HH:mm:ss").format(new Date()));
        synchronized (SyncThread.class) {
            try {
                System.out.println(Thread.currentThread().getName() + "_SyncClassBlock1_Start: " + new SimpleDateFormat("HH:mm:ss").format(new Date()));
                Thread.sleep(1000);
                System.out.println(Thread.currentThread().getName() + "_SyncClassBlock1_End: " + new SimpleDateFormat("HH:mm:ss").format(new Date()));
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }

    private synchronized static void syncClassMethod1() {
        System.out.println(Thread.currentThread().getName() + "_SyncClassMethod1: " + new SimpleDateFormat("HH:mm:ss").format(new Date()));
        try {
            System.out.println(Thread.currentThread().getName() + "_SyncClassMethod1_Start: " + new SimpleDateFormat("HH:mm:ss").format(new Date()));
            Thread.sleep(1000);
            System.out.println(Thread.currentThread().getName() + "_SyncClassMethod1_End: " + new SimpleDateFormat("HH:mm:ss").format(new Date()));
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
```

```java
public class SyncDemo {
    public static void main(String... args) {
        SyncThread syncThread = new SyncThread();
        Thread A_thread1 = new Thread(syncThread, "A_thread1");
        Thread A_thread2 = new Thread(syncThread, "A_thread2");
        Thread B_thread1 = new Thread(syncThread, "B_thread1");
        Thread B_thread2 = new Thread(syncThread, "B_thread2");
        Thread C_thread1 = new Thread(syncThread, "C_thread1");
        Thread C_thread2 = new Thread(syncThread, "C_thread2");
        Thread D_thread1 = new Thread(syncThread, "D_thread1");
        Thread D_thread2 = new Thread(syncThread, "D_thread2");
        Thread E_thread1 = new Thread(syncThread, "E_thread1");
        Thread E_thread2 = new Thread(syncThread, "E_thread2");
        A_thread1.start();
        A_thread2.start();
        B_thread1.start();
        B_thread2.start();
        C_thread1.start();
        C_thread2.start();
        D_thread1.start();
        D_thread2.start();
        E_thread1.start();
        E_thread2.start();
    }
}
```

![image-20190810144918539](/Users/dingyuanjie/Documents/study/github/woodyprogram/img/image-20190810144918539.png)

![image-20190810145152619](/Users/dingyuanjie/Documents/study/github/woodyprogram/img/image-20190810145152619.png)

![image-20190810145212451](/Users/dingyuanjie/Documents/study/github/woodyprogram/img/image-20190810145212451.png)

![image-20190810145726050](/Users/dingyuanjie/Documents/study/github/woodyprogram/img/image-20190810145726050.png)

![image-20190810145817374](/Users/dingyuanjie/Documents/study/github/woodyprogram/img/image-20190810145817374.png)

![image-20190810145900963](/Users/dingyuanjie/Documents/study/github/woodyprogram/img/image-20190810145900963.png)

![image-20190810145948338](/Users/dingyuanjie/Documents/study/github/woodyprogram/img/image-20190810145948338.png)

![image-20190810150340640](/Users/dingyuanjie/Documents/study/github/woodyprogram/img/image-20190810150340640.png)

![image-20190810150427240](/Users/dingyuanjie/Documents/study/github/woodyprogram/img/image-20190810150427240.png)

![image-20190810151133159](/Users/dingyuanjie/Documents/study/github/woodyprogram/img/image-20190810151133159.png)

![image-20190810151229305](/Users/dingyuanjie/Documents/study/github/woodyprogram/img/image-20190810151229305.png)

![image-20190810151339408](/Users/dingyuanjie/Documents/study/github/woodyprogram/img/image-20190810151339408.png)

![image-20190810151433452](/Users/dingyuanjie/Documents/study/github/woodyprogram/img/image-20190810151433452.png)

![image-20190810151556336](/Users/dingyuanjie/Documents/study/github/woodyprogram/img/image-20190810151556336.png)

![image-20190810151722584](/Users/dingyuanjie/Documents/study/github/woodyprogram/img/image-20190810151722584.png)

![image-20190810151759351](/Users/dingyuanjie/Documents/study/github/woodyprogram/img/image-20190810151759351.png)

![image-20190810151847944](/Users/dingyuanjie/Documents/study/github/woodyprogram/img/image-20190810151847944.png)

![image-20190810151939210](/Users/dingyuanjie/Documents/study/github/woodyprogram/img/image-20190810151939210.png)

![image-20190810152014284](/Users/dingyuanjie/Documents/study/github/woodyprogram/img/image-20190810152014284.png)

![image-20190810152101938](/Users/dingyuanjie/Documents/study/github/woodyprogram/img/image-20190810152101938.png)

![image-20190810152634452](/Users/dingyuanjie/Documents/study/github/woodyprogram/img/image-20190810152634452.png)

![image-20190810152708767](/Users/dingyuanjie/Documents/study/github/woodyprogram/img/image-20190810152708767.png)

![image-20190810152814167](/Users/dingyuanjie/Documents/study/github/woodyprogram/img/image-20190810152814167.png)

```java
public class ReentrantLockDemo implements  Runnable{
    private static ReentrantLock lock = new ReentrantLock(false);
    @Override
    public void run(){
        while (true){
            try{
                lock.lock();
                System.out.println(Thread.currentThread().getName() + " get lock");
                Thread.sleep(1000);
            } catch (Exception e){
                e.printStackTrace();
            } finally {
                lock.unlock();
            }
        }
    }

    public static void main(String[] args) {
        ReentrantLockDemo rtld = new ReentrantLockDemo();
        Thread thread1 = new Thread(rtld);
        Thread thread2 = new Thread(rtld);
        thread1.start();
        thread2.start();
    }
}
```

![image-20190810153142632](/Users/dingyuanjie/Documents/study/github/woodyprogram/img/image-20190810153142632.png)

![image-20190810153419871](/Users/dingyuanjie/Documents/study/github/woodyprogram/img/image-20190810153419871.png)

