# 数据库

* 如何定位并优化慢查询SQL

  - 具体场景具体分析，大致思路

    - 根据慢日志定位慢查询SQL

      ![image-20190807223734074](/Users/dingyuanjie/Documents/study/github/woodyprogram/img/image-20190807223734074.png)
      
      ![image-20190807223839044](/Users/dingyuanjie/Documents/study/github/woodyprogram/img/image-20190807223839044.png)
      
      ![image-20190807224032455](/Users/dingyuanjie/Documents/study/github/woodyprogram/img/image-20190807224032455.png)
      
      ![image-20190807224448859](/Users/dingyuanjie/Documents/study/github/woodyprogram/img/image-20190807224448859.png)

    - 使用explain等工具分析SQL
    
      ![image-20190807224635082](/Users/dingyuanjie/Documents/study/github/woodyprogram/img/image-20190807224635082.png)
    
      - Explain关键字段
    
        - type：是index或all时，需要优化
    
        ![image-20190807224732340](/Users/dingyuanjie/Documents/study/github/woodyprogram/img/image-20190807224732340.png)
    
        - extra
    
        ![image-20190807224836179](/Users/dingyuanjie/Documents/study/github/woodyprogram/img/image-20190807224836179.png)
    
    * 修改sql或尽量让sql走索引
    
      ![image-20190807225222917](/Users/dingyuanjie/Documents/study/github/woodyprogram/img/image-20190807225222917.png)
    
      ![image-20190807225420684](/Users/dingyuanjie/Documents/study/github/woodyprogram/img/image-20190807225420684.png)
    
      ![image-20190807225637130](/Users/dingyuanjie/Documents/study/github/woodyprogram/img/image-20190807225637130.png)
    
      ![image-20190807225857733](/Users/dingyuanjie/Documents/study/github/woodyprogram/img/image-20190807225857733.png)

* 联合索引的最左匹配原则的成因

  * 联合索引(a,b)，当where a = ''and b='' 或where a=''或where b=''and a=''时使用了联合索引；where b=''则没使用联合索引

  ![image-20190807230307576](/Users/dingyuanjie/Documents/study/github/woodyprogram/img/image-20190807230307576.png)

  ![image-20190807230704172](/Users/dingyuanjie/Documents/study/github/woodyprogram/img/image-20190807230704172.png)

  * 先给最先的字段排序，然后在该字段基础上给接下来的字段排序

* 索引是建立的越多越好吗

  ![image-20190807231600882](/Users/dingyuanjie/Documents/study/github/woodyprogram/img/image-20190807231600882.png)

## 锁模块

* MyISAM与InnoDB关于锁方面的区别是什么

  ![image-20190807231958043](/Users/dingyuanjie/Documents/study/github/woodyprogram/img/image-20190807231958043.png)

  * MyISAM

    * select * from person where id between 1 and 2000000;时会表锁 update person set account = account  where id = 2000001;会等待前面的select执行完才执行（如果是行级锁，则不会等待而是直接执行）
    * select时会加读锁，update需等待读锁释放后才加写锁进行数据更新
    * 显示加读锁/写锁：lock tables person read | write;
    * 释放读锁：unlock tables;
    * 读锁，也是共享锁；写锁，也是排他锁（读或写是不允许的）；
      * 除了给insert、delete、update加排他锁，也能给select加排他锁（select ... for update;）
    * 先加写锁，再加读锁，需先等待写锁释放后才能加读锁
      * update person set account=account where id between 1 and 2000000;
      * select * from person where id in (2000000,2000001);
    * 适合场景
      * 频繁执行全表count语句：不用扫描表，有个变量保存了整个表的行数，直接读取即可
      * 对数据进行增删改的频率不高，查询非常频繁
      * 没有事务

  * InnoDB

    ![image-20190807234320023](/Users/dingyuanjie/Documents/study/github/woodyprogram/img/image-20190807234320023.png)

    * InnoDB对select进行了改进：并未对select加读锁
    * 加共享锁：select .... lock in share mode;
    * InnoDB默认支持行级锁，不同行数据互不影响
    * InnoDB没有用到索引时，使用的是表级锁
    * 表级的意向锁
      * IS共享读锁、IX排他写锁
      * 与MyISAM的表锁差不多，表级别操作的时候不用去轮询每一行有没有上行锁
    * 适用场景
      * 数据增删改查都很频繁
      * 可靠性要求比较高，要求支持事务

  * 数据库锁的分类

    * 按锁的粒度划分，可分为表级锁、行级锁、页级锁
    * 按锁级别划分，可分为共享锁、排他锁
    * 按加锁方式划分，可分为自动锁、显示锁
    * 按操作划分，可分为DML锁、DDL锁
    * 按使用方式划分，可分为悲观锁、乐观锁

* 数据库事务四大特性

  * 原子性（Atomic）
  * 一致性（Consistency）
  * 隔离性（Isolation）
    * 查看隔离级别`select @@tx_isolation`
    * 更改当前Session的隔离级别`set session transaction isolation level read uncommitted`
  * 持久性（Durability）

* 事务隔离级别以及各级别下的并发访问问题

  * 事务并发访问引起的问题以及如何避免
    * 更新丢失-MySQL所有事物隔离级别在数据库层面上均可避免
    * 脏读-READ-COMMITTED事务隔离级别以上均可避免
      * `start transaction;`
      * `sql...;`
      * `rollback; 或 commit;`
    * 不可重复读-REPEATABLE-READ事务隔离级别以上可避免
      * REPEATABLE-READ，sessionA在其事务期间多次读取的数据都是一样的，即使期间被其他事物修改并提交
      * sessionA在sessionB事务提交之前更改了数据
      * sessionB查询得到的一直是sessionA更改之前的数据，但是sessionB是在sessionA提交后的数据基础之上更新数据
    * 幻读-SERIALIABLE事务隔离级别可避免
      * 幻读：事务A先查询（当前读-`select ... lock share in mode`）某范围内数据，事务B在该范围内新增或删除一条数据并提交，事务A再更新该范围内数据时会多或少更新数据
      * InnoDB的REPEATABLE-READ隔离级别可避免幻读
    * ![image-20190808070758066](/Users/dingyuanjie/Documents/study/github/woodyprogram/img/image-20190808070758066.png)

* InnoDB可重复读隔离级别下如何避免幻读

  * 表象：快照读（非阻塞读）- 伪MVCC
    * 当前读：共享锁和排他锁均为当前读，读取的是最新结果，并且读取后要保证其他并发事务不能修改结果，对结果加锁
      * `select ... lock in share mode`，共享锁
      * `select ... for update`，排他锁
      * `update、insert、delete`，排他锁
    * 快照读：不加锁的非阻塞读（SERIALIABLE级别的读是加锁的，为当前读模式select ... lock in share mode），select
      * 快照读是基于提升并发性能的考虑，是基于多版本并发控制MVCC来实现的，可以认为MVCC是行级锁的一个变种，在很多情况下避免加锁操作，开销更低，读取的可能不是最新版本而是历史版本
      * READ COMMITTED级别下，当前读和快照读的结果一致（事务期间读取到其他事物提交的最新结果）
      * READ REPEATBLE级别下，当前读读取的是最新数据，快照读可能读取的是历史版本数据（事务期间读取），快照创建的时期决定了事务读取的版本（快照读：sessionA期间先查询数据，sesionB更改并提交数据，sessionA再查询数据则为更改前的版本数据；sessionA先不查询数据，sessionB更改并提交数据，sessionA查询数据为最新版本数据）
  * 内在：next-key锁（行锁 + gap锁）
    * 行锁
    * gap锁（READ REPEATBLE、 SERIALIABLE）是个范围（左开右闭），不包括本身
      * 对主键索引或唯一索引会用gap锁吗？
        * 如果where条件全部命中，则不会用Gap锁、只会加记录锁
        * 如果where条件部分命中或者全不命中，则会加Gap锁
      * Gap锁会用在非唯一索引或者不走索引的当前读中

* RC、RR级别下的InnoDB的非阻塞读如何实现

  * 数据行里的DB_TRX_ID（最后一次修改本行数据的事务ID）、DB_ROLL_PTR（回滚指针）、DB_ROW_ID字段

  * undo日志

    * insert undo log

    * update undo log：delete和update时

      * 更新数据时，首先用排他锁锁住某行数据，将该行数据拷贝一份到undo log，然后修改当前行的值，填写事务id，使用回滚指针（DB_ROLL_PTR）指向undo log中那条修改前的数据  

        ![image-20190808212343234](/Users/dingyuanjie/Documents/study/github/woodyprogram/img/image-20190808212343234.png)

  * read view：可见性判断

* 语法部分

  * 关键语法（先根据需求列出sql子句，然后拼接）

    * Group By

      * 满足“SELECT 子句中的列名必须为分组列或列函数“
      * 列函数对于group by子句定义的每个组各返回一个结果

      ![image-20190808220214233](/Users/dingyuanjie/Documents/study/github/woodyprogram/img/image-20190808220214233.png)

      ![image-20190808220416827](/Users/dingyuanjie/Documents/study/github/woodyprogram/img/image-20190808220416827.png)

    * Having

      * 通常与Group By子句一起使用，指定Group By的过滤条件
      * where过滤行，Having过滤组；（如果省略了group by，那么having作用和where一样）
      * 出现在同一SQL中顺序：w here > group by > having

      ![image-20190808220954877](/Users/dingyuanjie/Documents/study/github/woodyprogram/img/image-20190808220954877.png)

    * 统计相关：COUNT、SUM、MAX、MIN、AVG

      ![image-20190808221240919](/Users/dingyuanjie/Documents/study/github/woodyprogram/img/image-20190808221240919.png)

      ![image-20190808221352400](/Users/dingyuanjie/Documents/study/github/woodyprogram/img/image-20190808221352400.png)

    ![image-20190808222215132](/Users/dingyuanjie/Documents/study/github/woodyprogram/img/image-20190808222215132.png)

    

  

