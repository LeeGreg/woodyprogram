# TCP/IP

* `Transmission Control Protocol`，即 传输控制协议

* ==TCP是一种面向连接的、可靠的、基于字节流、全双工通信的【传输层】通信协议==

  * 基于`TCP`的应用层协议有`HTTP`、`SMTP`、`FTP`、`Telnet` 和 `POP3`
  * 全双工：双方不仅都能发信息，而且能够同时发送
  * 半双工：双方都能发信息，但同一时间则只能一方发信息
  * 单工：一方只能发信息，另一方则只能收信息，通信是单向的

* ==OSI体系结构（7层）==：

  * 物理层-链路层-网络层 -传输层-会话层-表示层-应用层

* ==TCP/IP体系结构（4层）==：

  * 网络接口层-网际层（IP）-运输层（TCP/UDP）-应用层（HTTP）

* 五层体系结构

  * 物理层-链路层-网络层-运输层-应用层

* TCP /IP 通信协议（传输控制协议/互联⽹协议），在通信的两端各建立⼀个Socket，从而在通信的两端之间形成网络虚拟链路用于发送和接收数据

  * IP 协议只保证计算机能发送和接收分组数据，但还不能解决数据分组在传输过程中可能出现的问题 

    * IP地址，用于唯一地标识⽹络中的一个通信实体(可以有多个通信程序同时提供网络服务，端口0~65535)

  * TCP协议提供可靠并且无差错(重发机制，没收到确认回复则重发)的通信服务

  * Java使用Socket对象代表两端的通信端口，并通过Socket产生IO流来进行网络通信

    * ServerSocket创建TCP服务器端

      * 接收其他通信实体连接请求，其对象⽤于监听来自客户端的Socket连接，如果没有，则一直处于等待状态

      * 服务器端应该为每个Socket单独启动一个线程，每个线程负责与一个客户端进⾏通信

        ```java
        ServerSocket ss = new ServerSocket(30000); //没有指定IP则默认本机IP
        while(true) {
        //每当接收到客户端Socket的请求时，服务器端也对应产生⼀个Socket 
            Socket s = ss.accept();
        	...
        }
        //连接建⽴后，通过使用 I/O 流在进行通信，每一个socket都有⼀个输出流和⼀个输⼊流，客户端的输出流连接到服务器端的输入流，而客户端的输入流连接到服务器端的输出流
        //TCP 是⼀个双向的通信协议，因此数据可以通过两个数据流在同一时间发送
        ```

    * 客户端可以使用Socket的构造器来连接到指定服务器

      * 客户端需要和服务器端保持长时间通信

        ```java
        //连接到指定服务器，让服务器端的ServerSocket的accept()向下执行 
        //服务器端和客户端就产生一对相互连接的Socket
        Socket s = new Socket("IP",端口);
        s.setSoTimeout(1000); //设置超时 //程序⽆需区分服务器端、客户端，⽽是通过各自的Socket进行通信 
        getInputStream()
        getOutputStream() //程序从Socket中取出数据，向Socket中输出数据
        ```

    * URI：统一资源标志符，不能⽤于定位任何资源，唯一作⽤就是解析

    * URL：统一资源定位器，指向互联网“资源”的指针，URI的特例

      ```java
      URL url = new URL(path); 
      openConnection()//代表了与URL所引用的远程对象的连接
      openStream() //打开与此URL的连接，并返回⼀个用于读取该URL资源的InputStream
      ```

## Socket

* socket即套接字，本质是一个封装了 TCP / IP协议族的编程接口(API)，可做网络通信开发，是对TCP/IP的封装
  * HTTP是轿车，提供了封装或者显示数据的具体形式；Socket是发动机，提供了==网络通信的能力==
* 一个 `Socket` 实例唯一代表一个主机上的一个应用程序的通信链路
* `Socket`可基于`TCP`或者`UDP`协议，但TCP更加常用
* 服务器
  * 创建一个ServerSocket实例，监听指定端口，阻塞等待客户端的连接请求，完成三次握手，返回服务端Socket实例，然后服务端和客户端可进行通信
* 客户端
  * 创建一个Socket实例，分配本地端口，通过远程地址、端口号连接远程服务端，完成三次握手，Socket实例创建完成
* Socket 与 Http 对比

  * `Socket`属于传输层，因为 `TCP / IP`协议属于传输层，**解决的是数据如何在网络中传输的问题**
  * `HTTP`协议 属于应用层，**解决的是如何包装数据**
  * `Http`：采用 **请求—响应** 方式，即建立网络连接后，当客户端向服务器发送请求后，服务器端才能向客户端返回数据
  * `Socket`：采用 **服务器主动发送数据** 的方式，即建立网络连接后，服务器可主动发送消息给客户端

## 三次握手

tcp，三次传输，以确保任何一次失败的连接都不会长时间占用资源

1. 建立连接时，客户端向服务端发送消息，等待服务器确认，客户端进入同步已发送状态
2. 服务端接收并确认消息，若同意建立连接，则向客户端发送连接确认消息，服务器进入同步已接收状态
3. 客户端收到服务端的消息，向服务端发送确认收到消息，该消息发送完毕后，TCP连接成功，完成三次握手

* 防止服务器端因接收了**早已失效的连接请求报文**，从而一直等待客户端请求，最终导致**形成死锁、浪费资源**

## 四次挥手

1. 客户端向服务端发送连接释放消息
2. 服务端收到客户端发送释放连接消息后，向客户端发送连接释放确认消息
3. 若服务端已无要向客户端发送数据，则发出释放连接消息
4. 客户端接收到连接释放消息后，则向服务端发送连接释放确认消息

* 等待服务端的数据都发送完

## 滑动窗口机制

* ==无差错传输==
* ==是传输层进行流控的一种措施，接收方通过通告发送方自己的窗口大小，从而控制发送方的发送速度，从而达到防止发送方发送速度过快而导致自己被淹没的目的==
* ACK包含两个非常重要的信息：
  * 一是期望接收到的下一字节的序号n，该n代表接收方已经接收到了前n-1字节数据。
  * 二是当前的窗口大小m，如此发送方在接收到ACK包含的这两个数据后就可以计算出还可以发送多少字节的数据给对方，这就是滑动窗口控制流量的基本原理
* 发送端：
  * 每收到一个确认帧，发送窗口就向前滑动一个帧的距离
  * 当窗口内的帧全部是已发送但未收到确认的，发送方就会停止发送，直到收到接收方发送的确认帧使窗口移动，窗口内有可以发送的帧，之后才开始继续发送
* 接收端：
  * 当收到数据帧后，将窗口向前移动一个位置，并发回确认帧，若收到的数据帧落在接收窗口之外，则一律丢弃

## 和UDP的区别

* UDP协议：面向非连接（直接发送）、不可靠、一次只传送少量数据的用户数据报协议
  1. 应用在实时性很强的应用场景，⽐如网络游戏、视频会议等，快速更具独特性
  2. 主要作⽤：
     * 完成网络数据流和数据报之间的转换
     * 发送端 UDP将网络数据流转成数据报，再转成实际数据内容接收端

* ==TCP协议==：面向连接、可靠的字节流传输，传输⼤小无限制，但是差错控制开销⼤。对应的协议（FTP/SMTP/HTTP）
* ==UDP协议==：面向非连接、不可靠的数据报文段传输，传输⼤小限制在64kb以下，差错控制开销小。对应的协议（DNS）

## 在浏览器中输入网址会发生什么

1. 由域名到ip地址，寻址的过程
   * 经过了浏览器缓存、系统缓存、hosts文件、路由器缓存、递归搜索根域名服务器
2. 建立tcp/ip链接（三次握手的具体过程）
3. 由浏览器发送一个http请求
4. 经过路由器的转发，通过服务器的防火墙，该http请求到达了服务器
5. 服务器处理该http请求，返回一个响应
6. 浏览器解析响应

注意的是：http协议是基于tcp、ip的应用层协议，进行http传输之前必须进行tcp链接；http是轿车，提供了封装或者显示数据的具体形式；socket是发动机，提供了网络通信的能力；两个计算机之间的交流无非是两个端口之间的数据通信，具体的数据会以什么样的形式展示是以不同的应用层协议来定义的

## 阻塞IO和非阻塞IO

* TCP协议：对于TCP通信来说，每个TCP的socket的内核里面都会有发送缓冲区和接收缓冲区

* 接收端的接收缓冲区会把数据存到内核，如果应用进程一直没有调用到socket里面的read方法进行读取，那么这个数据会一直被缓存到缓存区里面，直到应用程序通过read去读取

  * 不管进程是否读取socket，对发送端来说，它的数据都会经过内核接收并且缓存到socket的内存缓冲区，read把内核接收的缓冲区的数据赋值到应用层用户的buffer里面（从内核空间复制到应用空间）

  * 进程调用socket的send来发送数据的时候，一般情况下是把数据从应用层复制到socket的 内核发送缓冲区。send是异步的，send返回时，数据不一定发送到了接收缓冲区。

  * 接收缓冲区的数据如果一直没有被读取，直到满了过后会通知TCP的对端关闭窗口，保证TCP接收端的接收缓冲区数据不会被移除，这样就保证 了消息的传输性（可能是利用滑动窗口协议来做的）——限流

    ![image-20190116073023970](/Users/dingyuanjie/Desktop/mynotes/MD/网络/image-20190116073023970-7595024.png)

* 阻塞IO

  * （发送消息时对方要准备好，否则处于阻塞，接收端也一样）
  * （浪费资源，任何一个过程比较慢的话，会导致整个过程慢）
  * 对于读取socket数据过程而言，如果接收缓冲数据为空的话，socket调用read的方法后，线程会处于阻塞状态，直到有数据到接收缓冲区
  * 对于写入socket发送缓冲区，如果待发送的缓冲区的数据长度大于发送缓冲区本身空余的长度，这时候会阻塞到wait方法上，必须要等到发送缓冲区的报文全部发送到网络上以后，才能继续发送下一个报文

* 非阻塞IO

  * 用来解决IO线程和Socket解耦的问题，引入一个事件机制来达到解耦 ，可以认为底层存在一个IO线程调度，它不断的扫描每一个socket缓冲区，当发现写（发送）缓冲区为空，会产生一个socket可写事件通知发送端的一个线程去写数据，如果一次写不完，会等到下一次；反之，对于接受端来说，如果发现接收端的缓冲区可读时，它会发 送一个事件，如果不能读，就不会处于阻塞状态，就会去其他事情
  * 事件机制涉其实就是IO多路复用的一个模型，在Linux里可以使用select、inpo等方式。当线程准备去读接收缓冲区时，发现接收缓冲区还没准备好，那不会等待，会把线程放入 select这样的调度系统里，select系统里有N个这样的线程，当可读的时候，会发送一个事件通知select选择一个事件去执行，这就完美地利用事件机制来达到非阻塞IO的一个情况，充分利用了资源

* BIO

  * 同步阻塞
  * 同步：是否要亲自去监听操作，不断进行关注，是否已经完成对应的操作呢
  * 阻塞：IO操作如果没有完成，在单线程的情况下，当前线程一定会等待在这边，没有办法进行其他操作
  * 每来一个客户端的Socket连接，都会针对这个Socket创建出一个线程，为IO操作进行处理；多线程的方式解决了多个客户端同时进行连接的情况
  * 问题来了，针对多个客户端连接，服务端的线程数量肯定会增加的
  * 改良方案：在IO操作的时候进行创建线程进行处理。

* NIO

  * 同步非阻塞IO（同步：要自己不断的询问是否已经完成；非阻塞：IO 操作不需要再进行阻塞在那边，直接返回）

* AIO：异步非阻塞

  * 异步：用户发出了IO操作之后，这时候就不关心，委托给操作系统进行完成，当操作系统完成这个IO操作之后，再告诉自己就OK

* 同步(Synchronization)和异步(Asynchronous)的方式

  * 同步和异步都是基于应用程序和操作系统处理 IO 事件所采用的方式
  * 同步：是应用程序要直接参与 IO 读写的操作
    * 同步方式在处理 IO 事件的时候，必须阻塞在某个方法上面等待我们的 IO 事件完成(阻塞 IO 事件或者通过轮询 IO 事件的方式)
    * 同步:1)阻塞到 IO 事件，阻塞到 read 或则 write。这个时候我们就完全不能做自己的事情。让读写方法加入到线程里面，然后阻塞线程来实现，对线程的性能开销比较大
  * 异步：所有的 IO 读写交给操作系统去处理，应用程序只需要等待通知
    * 所有的 IO 读写都交给了操作系统。
    * 这个时候，我们可以去做其他的事情，并不需要去完成真正的 IO 操作，当操作完成 IO 后，会给我们的应用程序一个通知

# HTTP

* 是==基于TCP/IP协议的【应用层】协议。它不涉及数据包传输，主要规定了客户端和服务器之间的通信格式==，是互联网信息交互中最常用的协议，用GET/POST/DELETE/PUT来实现RESTFUL
* `HTTP`协议采用 ==请求 / 响应== 的工作方式
* 特点
  1. 简单快速。只需要传【请求方法】与【资源路径】就能确定资源
  2. 灵活，传输【任意类型】的数据
  3. 无连接，一般一次连接只处理一个请求，结束后主动释放连接，但可以使用keep-alive来复用相同的TCP连接发送多个请求
  4. 无状态，客户端向服务器发送HTTP请求之后，服务器会给我们发送数据过来，但不会记录任何信息。所以Cookie、Session产生了
* 与==WebSocket==的区别
  1. 支持长连接。把WebSocket一个新协议，可以看成是在HTTP协议上打上一个【支持长连接】的补丁
  2. 支持服务器推送。HTTP协议是接收请求然后响应。而WebSocket可以让服务器主动推送
  3. 基于HTTP。WebSocket是基于HTTP协议的，或者说借用了HTTP的协议来完成一部分握手

## REST/RESTful

* 是一种软件架构风格，不是一个标准，但大部分RESTful Web服务实现会使用HTTP、URI、JSON和XML等各种协议和标准
* 目的是便于不同软件/程序在网络中互相传递信息
* 要点和标准：
  * 资源是由URI来指定
  * 通过操作资源的表现形式来操作资源，资源的表现形式则是XML、HTML或者JSON
  * 对资源的操作包括创建、获取、修改和删除资源，这些操作正好对应HTTP协议提供的POST、GET、PUT和DELETE方法
* 优点
  * 可更高效利用缓存来提高响应速度
  * 通讯本身的无状态性可以让不同的服务器的处理一系列请求中的不同请求，提高服务器的扩展性
  * 浏览器即可作为客户端，简化软件需求
  * 相对于其他叠加在HTTP协议之上的机制，REST的软件依赖性更小
  * 不需要额外的资源发现机制
  * 在软件技术演进中的长期的兼容性更好
* REST架构风格最重要的架构约束有6个
  * （客户-服务器）通信只能由客户端单方面发起，表现为请求-响应的形式；客户端与服务器分离模式，任何一个客户端与服务器都是可替换的
  * （无状态）通信的会话状态应该全部由客户端负责维护
  * （缓存）响应内容可以在通信链的某处被缓存，以改善网络效率
  * （统一接口）通信链的组件之间通过统一的接口相互通信，以提高交互的可见性
    * 每个资源都可以通过URI访问到；通过客户端可以修改原资源的状态；返回信息足够描述自己，客户端可以知道如何处理；处理以超媒体为基础的状态变化
  * （分层系统）每个组件只能“看到”与其交互的紧邻层，将架构分解为若干等级的层
  * （按需代码）支持通过下载并执行一些代码，如JavaScript，对客户端的功能进行扩展
* 状态
  * 应该注意区别应用的状态和连接协议的状态。HTTP连接是无状态的（也就是不记录每个连接的信息），而REST传输会包含应用的所有状态信息，因此可以大幅降低对HTTP连接的重复请求资源消耗
* 应用于Web服务
  * 匹配REST设计风格的Web API称为**RESTful API**。它从以下三个方面资源进行定义：
    * 直观简短的资源地址：URI
    * 传输的资源：Web服务接受与返回的互联网媒体类型，如JSON、XML等
    * 对资源的操作：Web服务在该资源上所支持的一系列请求方法（比如：POST，GET，PUT或DELETE）
  * **HTTP请求方法在RESTful API中的典型应用**
    * **GET**，可获取指定资源详细信息，格式可以是XML、JSON
      * 一个简单的网络商店应用，列举所有商品`GET http://www.store.com/products`
      * 呈现某一件商品`GET http://www.store.com/products/12345`
    * **PUT**，**替换/创建**指定的资源
    * **POST**，某个资源组下**创建/追加**一个新的元素
      * 下单购买，`POST http://www.store.com/orders`
    * **DELETE**，删除资源
    * PUT和DELETE方法是幂等方法。GET方法是安全方法（不会对服务器端有修改，因此当然也是幂等的）

# HTTPS

* 经由HTTP进行通信，但利用SSL/TLS来加密数据包
* 是一个确保数据在浏览器与服务器之间传输安全的协议
* HTTPS 由两部分组成：HTTP协议+SSL（TLS）协议，也就是在HTTP上又加了一层处理加密信息的模块，传输的数据都是加密后的数据
  * SSL，传输层安全性协议，目的是为互联网通信提供安全及数据完整性保障
    * 客户端向服务器端索要并验证公钥
    * 双方协商生成"对话密钥"
    * 双方采用"对话密钥"进行加密通信
* 原理：HTTPS在传输数据之前需要客户端与服务器进行一次握手，在握手过程中将确立双方加密传输数据的密码信息

