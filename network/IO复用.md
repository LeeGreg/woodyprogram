# I/O复用

- 文件描述符
  - 是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表
  - 当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符
- 进程预先告知内核，使得内核一旦发现进程指定的一个或多个I/O条件就绪（也就是说输入已准备好被读取，或者描述符已能承接更多的输出），它就通知进程，这个能力称为==I/O复用==，是由select和poll两个函数支持
- 网路应用场合
  - 当客户处理多个描述符（通常是交互式输入和网络套接字）时，必须使用I/O复用
  - 如果一个TCP服务器既要处理监听套接字，又要处理已连接套接字，一般就要使用I/O复用
  - 如果一个服务器既要处理TCP，又要处理UDP，一般就要使用I/O复用
  - 如果一个服务器要处理多个服务或者多个协议，一般要使用I/O复用

## I/O 模型

- ==一个输入操作通常包含两个不同的阶段：（1）等待数据准备好（2）从内核向进程复制数据==
- 对于一个套接字上的输入操作
  - 第一步，通常涉及等待数据从网络中到达，然后数据被复制到内核中的某个缓冲区
  - 第二步，把数据从内核缓冲区复制到应用进程缓冲区

### 阻塞式I/O

- 默认情况下，所有套接字都是阻塞的

  - 当发出一个不能立即完成的套接字调用时，其进程将被投入==睡眠==，等待相应操作完成。

  ![image-20190328222934014](/Users/dingyuanjie/Library/Application%20Support/typora-user-images/image-20190328222934014.png)

  - 把recvfrom函数视为系统调用，因为正在区分应用进程和内核。不论它如何实现，一般都会从在应用进程空间中运行==切换==到在内核空间中运行，一段时间之后再切换回来
  - 进程调用recvfrom，其系统调用直到数据到达且被复制到应用进程的缓冲区中或者发生错误才返回（常见错误是系统调用被信号中断）
  - 进程在从调用recvfrom开始到它返回的整段时间内是被阻塞的。
  - recvfrom成功返回后，应用进程开始处理数据

### 非阻塞式I/O

- 进程把一个套接字设置成非阻塞是在通知内核：

  - 当所请求的I/O操作非得把本进程投入睡眠才能完成时，==不要把本进程投入睡眠==，而是返回一个错误

    ![image-20190328223944140](/Users/dingyuanjie/Library/Application%20Support/typora-user-images/image-20190328223944140.png)

  - 当一个应用进程对一个非阻塞描述符==循环==调用recvfrom时，称之为轮询

  - 应用进程持续轮询内核，以查看某个操作是否就绪。

  - 往往耗费大量CPU时间

### I/O复用

- 可以调用select或poll，==阻塞==在这两个系统调用中的某一个上，而不是阻塞在真正的I/O系统调用上
- ![image-20190329074627629](/Users/dingyuanjie/Library/Application%20Support/typora-user-images/image-20190329074627629.png)
- 阻塞于select调用，等待数据套接字变为可读。当select返回套接字可读这一条件时，调用recvfrom把所读数据复制到应用进程缓冲区
- 由于使用select需要两个而不是单个系统调用，I/O复用还稍有劣势
- ==使用select的优势在于可以等待多个描述符就绪==

### 信号驱动式I/O

- 让内核在描述符就绪时发送SIGIO信号通知进程
- ![image-20190329075226800](/Users/dingyuanjie/Library/Application%20Support/typora-user-images/image-20190329075226800.png)
- 首先开启套接字的信号驱动式I/O功能，并通过sigaction系统调用安装一个信号处理函数。该系统调用将立即返回，我们的进程继续工作，也就是进程没有被阻塞
- 当数据准备好读取时，内核就为该进程产生一个SIGIO信号
- 我们随后既可以在信号处理函数中调用recvfrom读取数据，并通知主循环数据已准备好待处理，也可以立即通知主循环，让它读取数据
- 无论如何处理SIGIO信号，这种模型的==优势==在于等待数据到达期间进程不被阻塞。主循环可以继续执行，只要等待来自信号处理函数的通知：既可以是数据已准备好被处理，也可以是数据已准备好被读取

### 异步I/O

- ==工作机制==：告知内核启动某个操作，并让内核在整个操作（包括将数据从内核复制到我们自己的缓冲区）完成后通知我们
- 与信号驱动模型的区别：
  - 信号驱动式I/O是由内核通知我们何时可以启动一个I/O操作
  - 异步I/O模型是由内核通知我们I/O操作何时完成
- ![image-20190329080450691](/Users/dingyuanjie/Library/Application%20Support/typora-user-images/image-20190329080450691.png)
- 调用aio_read函数，给内核传递描述符、缓冲区指针、缓冲区大小（与read相同的三个参数）和文件偏移，并告诉内核当整个操作完成时如何通知我们
- 该系统调用立即返回，而且在等待I/O完成期间，我们的进程不被阻塞
- 要求内核在操作完成时产生某个信号。该信号直到数据已复制到应用进程缓冲区才产生，这一点不同于信号驱动式I/O模型

## 各种I/O比较

- 阻塞式IO、非阻塞式IO、IO复用、信号驱动式IO
  - 主要区别在第一阶段
  - 第二阶段是一样的
    - 在数据从内核复制到调用者的缓冲区期间，进程阻塞于recvfrom调用
  - 相反，异步IO模型在这两个阶段都要处理，从而不同于其他四种模型
- 同步IO和异步IO对比
  - 同步IO操作：导致请求进程阻塞，直到IO操作完成
  - 异步IO操作：不导致请求进程阻塞
  - ![image-20190329110250620](/Users/dingyuanjie/Library/Application%20Support/typora-user-images/image-20190329110250620.png)
  - 阻塞式IO、非阻塞式IO、IO复用、信号驱动式IO都是同步型I/O模型，因为其中真正的IO操作（recvfrom）将阻塞进程

## Select函数

- 该函数允许进程指示内核等待多个事件中的任何一个发生，并只在有一个或多个事件发生或经历一段指定的时间后才唤醒它
- 调用select告知内核对哪些描述符（就读、写或异常条件）感兴趣以及等待多长时间

## 阻塞式IO

可能阻塞的套接字调用可分为一下四类：

- 输入操作，包括read、readv、recv、recvfrom和recvmsg共5个函数。如果某个进程对一个阻塞的TCP套接字（默认设置）调用这些输入函数之一，而且该套接字的接收缓冲区中没有数据可读，该进程将被投入睡眠，直到有一些数据到达。
  - 对于非阻塞的套接字，如果输入操作不能被满足（对于TCP套接字即至少有一个字节的数据可读，对于UDP套接字即有一个完整的数据报可读），相应调用将立即返回一个EWOULDBLOCK错误
- 输出操作，包括write、writev、send、sentto和sendmsg共5个函数，对于一个TCP套接字，内核将从应用进程的缓冲区到该套接字的发送缓冲区复制数据
  - 对于阻塞的套接字，如果其发送缓冲区中没有空间，进程将被投入睡眠，直到有空间为止
  - 对于一个非阻塞的TCP套接字，如果其发送缓冲区中根本没有空间，输出函数调用将立即返回一个EWOULDBLOCK错误。如果其发送缓冲区中有一些空间，返回值将是内核能够复制到该缓冲区中的字节数。这个字节数也称为不足计数
- 接受外来连接，即accept函数。如果对一个阻塞的套接字调用accept函数，并且尚无新的连接到达，调用进程将被投入睡眠。如果对一个非阻塞的套接字调用accept函数，并且尚无新的连接到达，accpet调用将立即返回一个EWOULDBLOCK错误
- 发起外出链接，即用于TCP的connect函数。TCP的每个connect总会阻塞其调用进程至少一个到服务器的RTT时间。如果对一个非阻塞的TCP套接字调用connect，并且连接不能立即建立，那么连接的建立能照样发起，不过会返回一个EINPROGRESS错误。有些连接可以立即建立，通常发生在服务器和客户处于同一个主机的情况下。



